/*
Polaris Server

一个支持多语言、多框架的云原生服务发现和治理中心  提供高性能SDK和无侵入Sidecar两种接入方式  

API version: v0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package polaris

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ServicesApiService ServicesApi service
type ServicesApiService service

type ApiCreateServiceAliasRequest struct {
	ctx _context.Context
	ApiService *ServicesApiService
	body *V1ServiceAlias
}

// create service alias
func (r ApiCreateServiceAliasRequest) Body(body V1ServiceAlias) ApiCreateServiceAliasRequest {
	r.body = &body
	return r
}

func (r ApiCreateServiceAliasRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateServiceAliasExecute(r)
}

/*
CreateServiceAlias 创建服务别名


用户可以为服务创建别名，可以通过别名来访问服务的资源数据。

请求示例：

~~~
POST /naming/v1/service/alias

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

{
    "service":"...",
    "namespace":"...",
    "alias":"...",
    "alias_namespace":"...",
    "comment":"..."
}
~~~

应答示例：

~~~json
{
    "code":200000,
    "info":"...",
    "alias":{
        "service":"...",
        "namespace":"...",
        "alias":"...",
        "alias_namespace":"...",
        "comment":"..."
    }
}
~~~

数据结构：

| 参数名          | 类型   | 描述                   | 必填 |
| --------------- | ------ | ---------------------- | ---- |
| alias           | string | 服务别名               | 是   |
| alias_namespace | string | 服务别名所属命名空间   | 是   |
| service         | string | 指向的服务名           | 是   |
| namespace       | string | 指向的服务所属命名空间 | 是   |
| comment         | string | 服务别名描述           | 否   |


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateServiceAliasRequest
*/
func (a *ServicesApiService) CreateServiceAlias(ctx _context.Context) ApiCreateServiceAliasRequest {
	return ApiCreateServiceAliasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ServicesApiService) CreateServiceAliasExecute(r ApiCreateServiceAliasRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicesApiService.CreateServiceAlias")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/service/alias"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateServicesRequest struct {
	ctx _context.Context
	ApiService *ServicesApiService
	body *[]V1Service
}

// create services
func (r ApiCreateServicesRequest) Body(body []V1Service) ApiCreateServicesRequest {
	r.body = &body
	return r
}

func (r ApiCreateServicesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateServicesExecute(r)
}

/*
CreateServices 创建服务


请求示例：

~~~
POST /naming/v1/services

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

[
    {
        "name":"...",
        "namespace":"...",
        "metadata":{

        },
        "ports":"...",
        "business":"...",
        "department":"...",
        "comment":"..."
    }
]
~~~

应答示例：

~~~json
{
    "code":200000,
    "info":"...",
    "size":1,
    "responses":[
        {
            "code":200000,
            "info":"...",
            "service":{
                "name":"...",
                "namespace":"..."
            }
        }
    ]
}
~~~

数据结构：

| 参数名           | 类型               | 描述                                                       | 是否必填 |
| ---------------- | ------------------ | ---------------------------------------------------------- | -------- |
| name             | string             | 服务名                                                     | 是       |
| namespace        | string             | 命名空间                                                   | 是       |
| metadata         | map<string,string> | 服务标签/元数据                                            | 否       |
| ports            | string             | 端口列表，多个port以逗号分隔                               | 否       |
| business         | string             | 服务所属业务，建议填写。                                   | 否       |
| department       | string             | 服务所属部门，建议填写。                                   | 否       |
| comment          | string             | 描述                                                       | 否       |
| user_ids         | []string           | 可以操作该资源的用户，**仅当开启北极星鉴权时生效**         | 否       |
| group_ids        | []string           | 可以操作该资源的用户组，，**仅当开启北极星鉴权时生效**     | 否       |
| remove_user_ids  | []string           | 被移除的可操作该资源的用户，**仅当开启北极星鉴权时生效**   | 否       |
| remove_group_ids | []string           | 被移除的可操作该资源的用户组，**仅当开启北极星鉴权时生效** | 否       |


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateServicesRequest
*/
func (a *ServicesApiService) CreateServices(ctx _context.Context) ApiCreateServicesRequest {
	return ApiCreateServicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ServicesApiService) CreateServicesExecute(r ApiCreateServicesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicesApiService.CreateServices")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteServiceAliasesRequest struct {
	ctx _context.Context
	ApiService *ServicesApiService
	body *[]V1ServiceAlias
}

// delete service aliases
func (r ApiDeleteServiceAliasesRequest) Body(body []V1ServiceAlias) ApiDeleteServiceAliasesRequest {
	r.body = &body
	return r
}

func (r ApiDeleteServiceAliasesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteServiceAliasesExecute(r)
}

/*
DeleteServiceAliases 删除服务别名


请求示例：

~~~
POST /naming/v1/service/aliases/delete

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

[
    {
        "alias":"...",
        "alias_namespace":"..."
    }
]
~~~

应答示例：

~~~json
{
    "code":200000,
    "info":"...",
    "size":1,
    "responses":[
        {
            "code":200000,
            "info":"...",
            "alias":{
                "alias":"...",
                "alias_namespace":"..."
            }
        }
    ]
}
~~~

数据结构：

| 参数名          | 类型   | 描述                  | 必填 |
| --------------- | ------ | --------------------- | ---- |
| alias           | string | 服务别名              | 是   |
| alias_namespace | string | 服务别名所属命名空间  | 是   |


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteServiceAliasesRequest
*/
func (a *ServicesApiService) DeleteServiceAliases(ctx _context.Context) ApiDeleteServiceAliasesRequest {
	return ApiDeleteServiceAliasesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ServicesApiService) DeleteServiceAliasesExecute(r ApiDeleteServiceAliasesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicesApiService.DeleteServiceAliases")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/service/aliases/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteServicesRequest struct {
	ctx _context.Context
	ApiService *ServicesApiService
	body *[]V1Service
}

// delete services
func (r ApiDeleteServicesRequest) Body(body []V1Service) ApiDeleteServicesRequest {
	r.body = &body
	return r
}

func (r ApiDeleteServicesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteServicesExecute(r)
}

/*
DeleteServices 删除服务


删除一个不存在的服务，认为删除成功

请求示例：

~~~
POST /naming/v1/services/delete

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

[
    {
        "name":"...",
        "namespace":"..."
    }
]
~~~

应答示例：

~~~json
{
    "code":200000,
    "info":"...",
    "size":1,
    "responses":[
        {
            "code":200000,
            "info":"...",
            "service":{
                "name":"...",
                "namespace":"..."
            }
        }
    ]
}
~~~

数据结构：

| 参数名    | 类型   | 描述     | 是否必填 |
| --------- | ------ | -------- | -------- |
| name      | string | 服务名   | 是       |
| namespace | string | 命名空间 | 是       |


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteServicesRequest
*/
func (a *ServicesApiService) DeleteServices(ctx _context.Context) ApiDeleteServicesRequest {
	return ApiDeleteServicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ServicesApiService) DeleteServicesExecute(r ApiDeleteServicesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicesApiService.DeleteServices")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/services/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCircuitBreakerByServiceRequest struct {
	ctx _context.Context
	ApiService *ServicesApiService
	service string
	namespace string
}


func (r ApiGetCircuitBreakerByServiceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetCircuitBreakerByServiceExecute(r)
}

/*
GetCircuitBreakerByService 根据服务查询熔断规则


请求示例：

~~~
GET /naming/v1/service/circuitbreaker?service=xxx&namespace=xxx

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}
~~~

应答示例：

~~~json
{
    "code":200000,
    "info":"execute success",
    "size":1,
    "configWithServices":[
        {
            "services":[

            ],
            "circuitBreaker": {
                "id": "xxx",
                "version": "xxx",
                "name": "xxx",
                "namespace": "xxx",
                "service": "xxx",
                "service_namespace": "xxx",
                "inbounds": [
                    {
                        "sources":[
                            {
                                "service":"*",
                                "namespace":"*"
                            }
                        ],
                        "destinations":[
                            {
                                "policy":{
                                    "errorRate":{
                                        "enable":true,
                                        "errorRateToOpen":10,
                                        "requestVolumeThreshold":10
                                    }
                                },
                                "recover":{
                                    "sleepWindow":"1s",
                                    "outlierDetectWhen":"NEVER"
                                },
                                "resource":"INSTANCE",
                                "method":{
                                    "value":"qweqwe"
                                }
                            }
                        ]
                    }
                ],
                "outbounds":  [
                    {
                        "sources":[
                            {
                                "service":"*",
                                "namespace":"*"
                            }
                        ],
                        "destinations":[
                            {
                                "policy":{
                                    "errorRate":{
                                        "enable":true,
                                        "errorRateToOpen":10,
                                        "requestVolumeThreshold":10
                                    }
                                },
                                "recover":{
                                    "sleepWindow":"1s",
                                    "outlierDetectWhen":"NEVER"
                                },
                                "resource":"INSTANCE",
                                "method":{
                                    "value":"qweqwe"
                                }
                            }
                        ]
                    }
                ]
            }
        }
    ]
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service 服务名
 @param namespace 命名空间
 @return ApiGetCircuitBreakerByServiceRequest
*/
func (a *ServicesApiService) GetCircuitBreakerByService(ctx _context.Context, service string, namespace string) ApiGetCircuitBreakerByServiceRequest {
	return ApiGetCircuitBreakerByServiceRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		namespace: namespace,
	}
}

// Execute executes the request
func (a *ServicesApiService) GetCircuitBreakerByServiceExecute(r ApiGetCircuitBreakerByServiceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicesApiService.GetCircuitBreakerByService")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/service/circuitbreaker"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", _neturl.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetServiceAliasesRequest struct {
	ctx _context.Context
	ApiService *ServicesApiService
}


func (r ApiGetServiceAliasesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetServiceAliasesExecute(r)
}

/*
GetServiceAliases 查询服务别名


请求示例：

~~~
GET /naming/v1/service/aliases

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

~~~

应答示例：

| 参数名 | 类型   | 描述                                                                                                            |
| ------ | ------ | --------------------------------------------------------------------------------------------------------------- |
| size   | uint32 | 本次查询返回的服务别名个数，例如查询命名空间为Production的服务别名，总数为1000，本次返回100条，则size为100      |
| info   | string | 返回信息                                                                                                        |
| code   | uint32 | 六位返回码                                                                                                      |
| amount | uint32 | 符合此查询条件的服务别名总数，例如查询命名空间为Production的服务别名，总数为1000，本次返回100条，则amount为1000 |

~~~json
{
    "code":200000,
    "info":"...",
    "amount":1,
    "size":1,
    "aliases":[
        {
            "alias":"...",
            "alias_namespace":"...",
            "namespace":"...",
            "service":"...",
            "comment":"...",
            "ctime":"...",
            "mtime":"..."
        }
    ]
}
~~~

数据结构：

| 参数名          | 类型   | 描述                         | 必填 |
| --------------- | ------ | ---------------------------- | ---- |
| alias           | string | 服务别名                     | 否   |
| alias_namespace | string | 服务别名所属命名空间         | 否   |
| service         | string | 指向的服务名                 | 否   |
| namespace       | string | 指向的服务所属命名空间       | 否   |
| offset          | int    | 分页偏移，默认0              | 否   |
| limit           | int    | 分页大小，默认为100，最大100 | 否   |


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetServiceAliasesRequest
*/
func (a *ServicesApiService) GetServiceAliases(ctx _context.Context) ApiGetServiceAliasesRequest {
	return ApiGetServiceAliasesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ServicesApiService) GetServiceAliasesExecute(r ApiGetServiceAliasesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicesApiService.GetServiceAliases")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/service/aliases"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetServiceOwnerRequest struct {
	ctx _context.Context
	ApiService *ServicesApiService
}


func (r ApiGetServiceOwnerRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetServiceOwnerExecute(r)
}

/*
GetServiceOwner 根据服务获取服务负责人

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetServiceOwnerRequest
*/
func (a *ServicesApiService) GetServiceOwner(ctx _context.Context) ApiGetServiceOwnerRequest {
	return ApiGetServiceOwnerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ServicesApiService) GetServiceOwnerExecute(r ApiGetServiceOwnerRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicesApiService.GetServiceOwner")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/service/owner"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetServiceTokenRequest struct {
	ctx _context.Context
	ApiService *ServicesApiService
}


func (r ApiGetServiceTokenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetServiceTokenExecute(r)
}

/*
GetServiceToken 查询服务Token

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetServiceTokenRequest

Deprecated
*/
func (a *ServicesApiService) GetServiceToken(ctx _context.Context) ApiGetServiceTokenRequest {
	return ApiGetServiceTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
// Deprecated
func (a *ServicesApiService) GetServiceTokenExecute(r ApiGetServiceTokenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicesApiService.GetServiceToken")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/service/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetServicesRequest struct {
	ctx _context.Context
	ApiService *ServicesApiService
	name *string
	namespace *string
	business *string
	department *string
	host *string
	port *string
	keys *string
	values *string
	offset *int32
	limit *int32
}

// 服务名
func (r ApiGetServicesRequest) Name(name string) ApiGetServicesRequest {
	r.name = &name
	return r
}
// 命名空间
func (r ApiGetServicesRequest) Namespace(namespace string) ApiGetServicesRequest {
	r.namespace = &namespace
	return r
}
// 业务，默认模糊查询
func (r ApiGetServicesRequest) Business(business string) ApiGetServicesRequest {
	r.business = &business
	return r
}
// 部门
func (r ApiGetServicesRequest) Department(department string) ApiGetServicesRequest {
	r.department = &department
	return r
}
// 实例IP，**多个IP以英文逗号分隔**
func (r ApiGetServicesRequest) Host(host string) ApiGetServicesRequest {
	r.host = &host
	return r
}
// **实例端口**，**多个端口以英文逗号分隔** 
func (r ApiGetServicesRequest) Port(port string) ApiGetServicesRequest {
	r.port = &port
	return r
}
// 服务元数据名，keys和values需要同时填写，目前只支持查询一组元数据。
func (r ApiGetServicesRequest) Keys(keys string) ApiGetServicesRequest {
	r.keys = &keys
	return r
}
// 服务元数据名，keys和values需要同时填写，目前只支持查询一组元数据。
func (r ApiGetServicesRequest) Values(values string) ApiGetServicesRequest {
	r.values = &values
	return r
}
// 查询偏移量
func (r ApiGetServicesRequest) Offset(offset int32) ApiGetServicesRequest {
	r.offset = &offset
	return r
}
// 查询条数，**最多查询100条**
func (r ApiGetServicesRequest) Limit(limit int32) ApiGetServicesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetServicesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetServicesExecute(r)
}

/*
GetServices 获取服务列表


请求示例：

~~~
GET /naming/v1/services?参数名=参数值

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}
~~~

| 参数名     | 类型   | 描述                                                               | 是否必填 |
| ---------- | ------ | ------------------------------------------------------------------ | -------- |
| name       | string | 服务名                                                             | 否       |
| namespace  | string | 命名空间                                                           | 否       |
| business   | string | 业务，默认模糊查询                                                 | 否       |
| department | string | 部门                                                               | 否       |
| host       | string | 实例IP，**多个IP以英文逗号分隔**                                   | 否       |
| port       | string | **实例端口**，**多个端口以英文逗号分隔**                           | 否       |
| keys       | string | 服务元数据名，keys和values需要同时填写，目前只支持查询一组元数据。 | 否       |
| values     | string | 服务元数据值，keys和values需要同时填写，目前只支持查询一组元数据。 | 否       |
| offset     | int    | 默认为0                                                            | 否       |
| limit      | int    | 默认为100，最大100                                                 | 否       |

应答示例：

~~~json
{
    "code":200000,
    "info":"...",
    "amount":1,
    "size":1,
    "services":[
        {
            "name":"...",
            "namespace":"...",
            "metadata":{

            },
            "ports":"...",
            "business":"...",
            "department":"...",
            "comment":"...",
            "ctime":"...",
            "mtime":"...",
            "total_instance_count": 1,
            "healthy_instance_count":1
        }
    ]
}
~~~

| 参数名 | 类型   | 描述                                                                                                 |
| ------ | ------ | ---------------------------------------------------------------------------------------------------- |
| code   | uint32 | 六位返回码                                                                                           |
| info   | string | 返回信息                                                                                             |
| amount | uint32 | 符合此查询条件的服务总数，例如查询命名空间为default的服务，总数为1000，本次返回100条，则amount为1000 |
| size   | uint32 | 本次查询返回的服务个数，例如查询命名空间为default的服务，总数为1000，本次返回100条，则size为100      |


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetServicesRequest
*/
func (a *ServicesApiService) GetServices(ctx _context.Context) ApiGetServicesRequest {
	return ApiGetServicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ServicesApiService) GetServicesExecute(r ApiGetServicesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicesApiService.GetServices")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.business != nil {
		localVarQueryParams.Add("business", parameterToString(*r.business, ""))
	}
	if r.department != nil {
		localVarQueryParams.Add("department", parameterToString(*r.department, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.port != nil {
		localVarQueryParams.Add("port", parameterToString(*r.port, ""))
	}
	if r.keys != nil {
		localVarQueryParams.Add("keys", parameterToString(*r.keys, ""))
	}
	if r.values != nil {
		localVarQueryParams.Add("values", parameterToString(*r.values, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetServicesCountRequest struct {
	ctx _context.Context
	ApiService *ServicesApiService
}


func (r ApiGetServicesCountRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetServicesCountExecute(r)
}

/*
GetServicesCount 获取服务数量


请求示例：
~~~
GET /naming/v1/services/count
# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}
~~~

应答示例：
~~~json
{
  "code": 200000,
  "info": "execute success",
  "amount": 141,
  "size": 0,
  "namespaces": [],
  "services": [],
  "instances": [],
  "routings": [],
  "aliases": [],
  "rateLimits": [],
  "configWithServices": [],
  "platforms": [],
  "users": [],
  "userGroups": [],
  "authStrategies": [],
  "clients": []
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetServicesCountRequest
*/
func (a *ServicesApiService) GetServicesCount(ctx _context.Context) ApiGetServicesCountRequest {
	return ApiGetServicesCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ServicesApiService) GetServicesCountExecute(r ApiGetServicesCountRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicesApiService.GetServicesCount")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/services/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateServiceAliasRequest struct {
	ctx _context.Context
	ApiService *ServicesApiService
	body *V1ServiceAlias
}

// update service alias
func (r ApiUpdateServiceAliasRequest) Body(body V1ServiceAlias) ApiUpdateServiceAliasRequest {
	r.body = &body
	return r
}

func (r ApiUpdateServiceAliasRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateServiceAliasExecute(r)
}

/*
UpdateServiceAlias 更新服务别名


请求示例：

~~~
PUT /naming/v1/service/alias

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

{
    "service":"...",
    "namespace":"...",
    "alias":"...",
    "alias_namespace":"...",
    "comment":"..."
}
~~~

应答示例：

~~~json
{
    "code":200000,
    "info":"...",
    "alias":{
        "service":"...",
        "namespace":"...",
        "alias":"...",
        "alias_namespace":"...",
        "comment":"..."
    }
}
~~~

数据结构：

| 参数名          | 类型   | 描述                   | 必填 |
| --------------- | ------ | ---------------------- | ---- |
| alias           | string | 服务别名               | 是   |
| alias_namespace | string | 服务别名所属命名空间   | 是   |
| service         | string | 指向的服务名           | 是   |
| namespace       | string | 指向的服务所属命名空间 | 是   |
| comment         | string | 服务别名描述           | 否   |


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateServiceAliasRequest
*/
func (a *ServicesApiService) UpdateServiceAlias(ctx _context.Context) ApiUpdateServiceAliasRequest {
	return ApiUpdateServiceAliasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ServicesApiService) UpdateServiceAliasExecute(r ApiUpdateServiceAliasRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicesApiService.UpdateServiceAlias")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/service/alias"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateServiceTokenRequest struct {
	ctx _context.Context
	ApiService *ServicesApiService
}


func (r ApiUpdateServiceTokenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateServiceTokenExecute(r)
}

/*
UpdateServiceToken 更新服务Token

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateServiceTokenRequest

Deprecated
*/
func (a *ServicesApiService) UpdateServiceToken(ctx _context.Context) ApiUpdateServiceTokenRequest {
	return ApiUpdateServiceTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
// Deprecated
func (a *ServicesApiService) UpdateServiceTokenExecute(r ApiUpdateServiceTokenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicesApiService.UpdateServiceToken")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/service/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateServicesRequest struct {
	ctx _context.Context
	ApiService *ServicesApiService
	body *[]V1Service
}

// update services
func (r ApiUpdateServicesRequest) Body(body []V1Service) ApiUpdateServicesRequest {
	r.body = &body
	return r
}

func (r ApiUpdateServicesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateServicesExecute(r)
}

/*
UpdateServices 更新服务


请求示例：

~~~
PUT /naming/v1/services

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

[
    {
        "name":"...",
        "namespace":"...",
        "token":"...",
        "metadata":{

        },
        "ports":"...",
        "business":"...",
        "department":"...",
        "comment":"..."
    }
]
~~~

应答示例：

~~~json
{
    "code":200000,
    "info":"...",
    "size":1,
    "responses":[
        {
            "code":200000,
            "info":"...",
            "service":{
                "name":"...",
                "namespace":"..."
            }
        }
    ]
}
~~~

数据结构：

| 参数名           | 类型               | 描述                                                       | 是否必填 | 可否修改 |
| ---------------- | ------------------ | ---------------------------------------------------------- | -------- | -------- |
| name             | string             | 服务名                                                     | 是       | 否       |
| namespace        | string             | 命名空间                                                   | 是       | 否       |
| metadata         | map<string,string> | 服务标签/元数据                                            | 否       | 是       |
| ports            | string             | 端口列表，多个port以逗号分隔                               | 否       | 是       |
| business         | string             | 服务所属业务，建议填写。                                   | 否       | 是       |
| department       | string             | 服务所属部门，建议填写。                                   | 否       | 是       |
| comment          | string             | 描述                                                       | 否       | 是       |
| user_ids         | []string           | 可以操作该资源的用户，**仅当开启北极星鉴权时生效**         | 否       |
| group_ids        | []string           | 可以操作该资源的用户组，，**仅当开启北极星鉴权时生效**     | 否       |
| remove_user_ids  | []string           | 被移除的可操作该资源的用户，**仅当开启北极星鉴权时生效**   | 否       |
| remove_group_ids | []string           | 被移除的可操作该资源的用户组，**仅当开启北极星鉴权时生效** | 否       |


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateServicesRequest
*/
func (a *ServicesApiService) UpdateServices(ctx _context.Context) ApiUpdateServicesRequest {
	return ApiUpdateServicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ServicesApiService) UpdateServicesExecute(r ApiUpdateServicesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServicesApiService.UpdateServices")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
