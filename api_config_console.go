/*
Polaris Server

一个支持多语言、多框架的云原生服务发现和治理中心  提供高性能SDK和无侵入Sidecar两种接入方式  

API version: v0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package polaris

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// ConfigConsoleApiService ConfigConsoleApi service
type ConfigConsoleApiService service

type ApiBatchDeleteConfigFileRequest struct {
	ctx _context.Context
	ApiService *ConfigConsoleApiService
	body *V1ConfigFile
	deleteBy *string
}

// 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header Header X-Polaris-Token: {访问凭据} &#x60;&#x60;&#x60;[      {          \&quot;name\&quot;:\&quot;application.properties\&quot;,          \&quot;namespace\&quot;:\&quot;someNamespace\&quot;,          \&quot;group\&quot;:\&quot;someGroup\&quot;      } ] &#x60;&#x60;&#x60;
func (r ApiBatchDeleteConfigFileRequest) Body(body V1ConfigFile) ApiBatchDeleteConfigFileRequest {
	r.body = &body
	return r
}
// 操作人
func (r ApiBatchDeleteConfigFileRequest) DeleteBy(deleteBy string) ApiBatchDeleteConfigFileRequest {
	r.deleteBy = &deleteBy
	return r
}

func (r ApiBatchDeleteConfigFileRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.BatchDeleteConfigFileExecute(r)
}

/*
BatchDeleteConfigFile 批量删除配置文件

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchDeleteConfigFileRequest
*/
func (a *ConfigConsoleApiService) BatchDeleteConfigFile(ctx _context.Context) ApiBatchDeleteConfigFileRequest {
	return ApiBatchDeleteConfigFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigConsoleApiService) BatchDeleteConfigFileExecute(r ApiBatchDeleteConfigFileRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigConsoleApiService.BatchDeleteConfigFile")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/v1/configfiles/batchdelete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	if r.deleteBy != nil {
		localVarQueryParams.Add("deleteBy", parameterToString(*r.deleteBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateConfigFileRequest struct {
	ctx _context.Context
	ApiService *ConfigConsoleApiService
	body *V1ConfigFile
}

// 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header Header X-Polaris-Token: {访问凭据}  &#x60;&#x60;&#x60;{     \&quot;name\&quot;:\&quot;application.properties\&quot;,     \&quot;namespace\&quot;:\&quot;someNamespace\&quot;,     \&quot;group\&quot;:\&quot;someGroup\&quot;,     \&quot;content\&quot;:\&quot;redis.cache.age&#x3D;10\&quot;,     \&quot;comment\&quot;:\&quot;第一个配置文件\&quot;,     \&quot;tags\&quot;:[{\&quot;key\&quot;:\&quot;service\&quot;, \&quot;value\&quot;:\&quot;helloService\&quot;}],     \&quot;createBy\&quot;:\&quot;ledou\&quot;,     \&quot;format\&quot;:\&quot;properties\&quot; } &#x60;&#x60;&#x60; 
func (r ApiCreateConfigFileRequest) Body(body V1ConfigFile) ApiCreateConfigFileRequest {
	r.body = &body
	return r
}

func (r ApiCreateConfigFileRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateConfigFileExecute(r)
}

/*
CreateConfigFile 创建配置文件

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateConfigFileRequest
*/
func (a *ConfigConsoleApiService) CreateConfigFile(ctx _context.Context) ApiCreateConfigFileRequest {
	return ApiCreateConfigFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigConsoleApiService) CreateConfigFileExecute(r ApiCreateConfigFileRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigConsoleApiService.CreateConfigFile")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/v1/configfiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateConfigFileGroupRequest struct {
	ctx _context.Context
	ApiService *ConfigConsoleApiService
	body *V1ConfigFileGroup
}

// 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header Header X-Polaris-Token: {访问凭据}  &#x60;&#x60;&#x60; {     \&quot;name\&quot;:\&quot;someGroup\&quot;,     \&quot;namespace\&quot;:\&quot;someNamespace\&quot;,     \&quot;comment\&quot;:\&quot;some comment\&quot;,     \&quot;createBy\&quot;:\&quot;ledou\&quot; } &#x60;&#x60;&#x60;
func (r ApiCreateConfigFileGroupRequest) Body(body V1ConfigFileGroup) ApiCreateConfigFileGroupRequest {
	r.body = &body
	return r
}

func (r ApiCreateConfigFileGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateConfigFileGroupExecute(r)
}

/*
CreateConfigFileGroup 创建配置文件组

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateConfigFileGroupRequest
*/
func (a *ConfigConsoleApiService) CreateConfigFileGroup(ctx _context.Context) ApiCreateConfigFileGroupRequest {
	return ApiCreateConfigFileGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigConsoleApiService) CreateConfigFileGroupExecute(r ApiCreateConfigFileGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigConsoleApiService.CreateConfigFileGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/v1/configfilegroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateConfigFileTemplateRequest struct {
	ctx _context.Context
	ApiService *ConfigConsoleApiService
}


func (r ApiCreateConfigFileTemplateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateConfigFileTemplateExecute(r)
}

/*
CreateConfigFileTemplate 创建配置模板

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateConfigFileTemplateRequest
*/
func (a *ConfigConsoleApiService) CreateConfigFileTemplate(ctx _context.Context) ApiCreateConfigFileTemplateRequest {
	return ApiCreateConfigFileTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigConsoleApiService) CreateConfigFileTemplateExecute(r ApiCreateConfigFileTemplateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigConsoleApiService.CreateConfigFileTemplate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/v1/configfiletemplates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteConfigFileRequest struct {
	ctx _context.Context
	ApiService *ConfigConsoleApiService
	namespace *string
	group *string
	name *string
	deleteBy *string
}

// 命名空间
func (r ApiDeleteConfigFileRequest) Namespace(namespace string) ApiDeleteConfigFileRequest {
	r.namespace = &namespace
	return r
}
// 配置文件分组
func (r ApiDeleteConfigFileRequest) Group(group string) ApiDeleteConfigFileRequest {
	r.group = &group
	return r
}
// 配置文件
func (r ApiDeleteConfigFileRequest) Name(name string) ApiDeleteConfigFileRequest {
	r.name = &name
	return r
}
// 操作人
func (r ApiDeleteConfigFileRequest) DeleteBy(deleteBy string) ApiDeleteConfigFileRequest {
	r.deleteBy = &deleteBy
	return r
}

func (r ApiDeleteConfigFileRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteConfigFileExecute(r)
}

/*
DeleteConfigFile 创建配置文件

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteConfigFileRequest
*/
func (a *ConfigConsoleApiService) DeleteConfigFile(ctx _context.Context) ApiDeleteConfigFileRequest {
	return ApiDeleteConfigFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigConsoleApiService) DeleteConfigFileExecute(r ApiDeleteConfigFileRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigConsoleApiService.DeleteConfigFile")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/v1/configfiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.namespace == nil {
		return nil, reportError("namespace is required and must be specified")
	}
	if r.group == nil {
		return nil, reportError("group is required and must be specified")
	}
	if r.name == nil {
		return nil, reportError("name is required and must be specified")
	}

	localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	if r.deleteBy != nil {
		localVarQueryParams.Add("deleteBy", parameterToString(*r.deleteBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteConfigFileGroupRequest struct {
	ctx _context.Context
	ApiService *ConfigConsoleApiService
	namespace *string
	group *string
}

// 命名空间
func (r ApiDeleteConfigFileGroupRequest) Namespace(namespace string) ApiDeleteConfigFileGroupRequest {
	r.namespace = &namespace
	return r
}
// 配置文件分组
func (r ApiDeleteConfigFileGroupRequest) Group(group string) ApiDeleteConfigFileGroupRequest {
	r.group = &group
	return r
}

func (r ApiDeleteConfigFileGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteConfigFileGroupExecute(r)
}

/*
DeleteConfigFileGroup 删除配置文件

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteConfigFileGroupRequest
*/
func (a *ConfigConsoleApiService) DeleteConfigFileGroup(ctx _context.Context) ApiDeleteConfigFileGroupRequest {
	return ApiDeleteConfigFileGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigConsoleApiService) DeleteConfigFileGroupExecute(r ApiDeleteConfigFileGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigConsoleApiService.DeleteConfigFileGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/v1/configfilegroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.namespace == nil {
		return nil, reportError("namespace is required and must be specified")
	}
	if r.group == nil {
		return nil, reportError("group is required and must be specified")
	}

	localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllConfigFileTemplatesRequest struct {
	ctx _context.Context
	ApiService *ConfigConsoleApiService
}


func (r ApiGetAllConfigFileTemplatesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetAllConfigFileTemplatesExecute(r)
}

/*
GetAllConfigFileTemplates 获取配置模板

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllConfigFileTemplatesRequest
*/
func (a *ConfigConsoleApiService) GetAllConfigFileTemplates(ctx _context.Context) ApiGetAllConfigFileTemplatesRequest {
	return ApiGetAllConfigFileTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigConsoleApiService) GetAllConfigFileTemplatesExecute(r ApiGetAllConfigFileTemplatesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigConsoleApiService.GetAllConfigFileTemplates")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/v1/configfiletemplates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetConfigFileRequest struct {
	ctx _context.Context
	ApiService *ConfigConsoleApiService
	namespace *string
	group *string
	name *string
}

// 命名空间
func (r ApiGetConfigFileRequest) Namespace(namespace string) ApiGetConfigFileRequest {
	r.namespace = &namespace
	return r
}
// 配置文件分组
func (r ApiGetConfigFileRequest) Group(group string) ApiGetConfigFileRequest {
	r.group = &group
	return r
}
// 配置文件名
func (r ApiGetConfigFileRequest) Name(name string) ApiGetConfigFileRequest {
	r.name = &name
	return r
}

func (r ApiGetConfigFileRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetConfigFileExecute(r)
}

/*
GetConfigFile 拉取配置

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetConfigFileRequest
*/
func (a *ConfigConsoleApiService) GetConfigFile(ctx _context.Context) ApiGetConfigFileRequest {
	return ApiGetConfigFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigConsoleApiService) GetConfigFileExecute(r ApiGetConfigFileRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigConsoleApiService.GetConfigFile")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/v1/configfiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.namespace == nil {
		return nil, reportError("namespace is required and must be specified")
	}
	if r.group == nil {
		return nil, reportError("group is required and must be specified")
	}
	if r.name == nil {
		return nil, reportError("name is required and must be specified")
	}

	localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetConfigFileReleaseRequest struct {
	ctx _context.Context
	ApiService *ConfigConsoleApiService
	namespace *string
	group *string
	name *string
}

// 命名空间
func (r ApiGetConfigFileReleaseRequest) Namespace(namespace string) ApiGetConfigFileReleaseRequest {
	r.namespace = &namespace
	return r
}
// 配置文件分组
func (r ApiGetConfigFileReleaseRequest) Group(group string) ApiGetConfigFileReleaseRequest {
	r.group = &group
	return r
}
// 配置文件
func (r ApiGetConfigFileReleaseRequest) Name(name string) ApiGetConfigFileReleaseRequest {
	r.name = &name
	return r
}

func (r ApiGetConfigFileReleaseRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetConfigFileReleaseExecute(r)
}

/*
GetConfigFileRelease 获取配置文件最后一次全量发布信息

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetConfigFileReleaseRequest
*/
func (a *ConfigConsoleApiService) GetConfigFileRelease(ctx _context.Context) ApiGetConfigFileReleaseRequest {
	return ApiGetConfigFileReleaseRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigConsoleApiService) GetConfigFileReleaseExecute(r ApiGetConfigFileReleaseRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigConsoleApiService.GetConfigFileRelease")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/v1/configfiles/release"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.namespace == nil {
		return nil, reportError("namespace is required and must be specified")
	}
	if r.group == nil {
		return nil, reportError("group is required and must be specified")
	}
	if r.name == nil {
		return nil, reportError("name is required and must be specified")
	}

	localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetConfigFileReleaseHistoryRequest struct {
	ctx _context.Context
	ApiService *ConfigConsoleApiService
	namespace *string
	limit *int32
	group *string
	name *string
	offset *int32
}

// 命名空间
func (r ApiGetConfigFileReleaseHistoryRequest) Namespace(namespace string) ApiGetConfigFileReleaseHistoryRequest {
	r.namespace = &namespace
	return r
}
// 一页大小，最大为 100
func (r ApiGetConfigFileReleaseHistoryRequest) Limit(limit int32) ApiGetConfigFileReleaseHistoryRequest {
	r.limit = &limit
	return r
}
// 配置文件分组
func (r ApiGetConfigFileReleaseHistoryRequest) Group(group string) ApiGetConfigFileReleaseHistoryRequest {
	r.group = &group
	return r
}
// 配置文件
func (r ApiGetConfigFileReleaseHistoryRequest) Name(name string) ApiGetConfigFileReleaseHistoryRequest {
	r.name = &name
	return r
}
// 翻页偏移量 默认为 0
func (r ApiGetConfigFileReleaseHistoryRequest) Offset(offset int32) ApiGetConfigFileReleaseHistoryRequest {
	r.offset = &offset
	return r
}

func (r ApiGetConfigFileReleaseHistoryRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetConfigFileReleaseHistoryExecute(r)
}

/*
GetConfigFileReleaseHistory 获取配置文件发布历史记录

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetConfigFileReleaseHistoryRequest
*/
func (a *ConfigConsoleApiService) GetConfigFileReleaseHistory(ctx _context.Context) ApiGetConfigFileReleaseHistoryRequest {
	return ApiGetConfigFileReleaseHistoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigConsoleApiService) GetConfigFileReleaseHistoryExecute(r ApiGetConfigFileReleaseHistoryRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigConsoleApiService.GetConfigFileReleaseHistory")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/v1/configfiles/releasehistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.namespace == nil {
		return nil, reportError("namespace is required and must be specified")
	}
	if r.limit == nil {
		return nil, reportError("limit is required and must be specified")
	}

	localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	if r.group != nil {
		localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPublishConfigFileRequest struct {
	ctx _context.Context
	ApiService *ConfigConsoleApiService
	body *V1ConfigFileRelease
}

// 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header Header X-Polaris-Token: {访问凭据} &#x60;&#x60;&#x60;{     \&quot;name\&quot;:\&quot;release-002\&quot;,     \&quot;fileName\&quot;:\&quot;application.properties\&quot;,     \&quot;namespace\&quot;:\&quot;someNamespace\&quot;,     \&quot;group\&quot;:\&quot;someGroup\&quot;,     \&quot;comment\&quot;:\&quot;发布第一个配置文件\&quot;,     \&quot;createBy\&quot;:\&quot;ledou\&quot; } &#x60;&#x60;&#x60;
func (r ApiPublishConfigFileRequest) Body(body V1ConfigFileRelease) ApiPublishConfigFileRequest {
	r.body = &body
	return r
}

func (r ApiPublishConfigFileRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PublishConfigFileExecute(r)
}

/*
PublishConfigFile 发布配置文件

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPublishConfigFileRequest
*/
func (a *ConfigConsoleApiService) PublishConfigFile(ctx _context.Context) ApiPublishConfigFileRequest {
	return ApiPublishConfigFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigConsoleApiService) PublishConfigFileExecute(r ApiPublishConfigFileRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigConsoleApiService.PublishConfigFile")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/v1/configfiles/release"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiQueryConfigFileGroupsRequest struct {
	ctx _context.Context
	ApiService *ConfigConsoleApiService
	limit *int32
	namespace *string
	group *string
	fileName *string
	offset *int32
}

// 一页大小，最大为 100
func (r ApiQueryConfigFileGroupsRequest) Limit(limit int32) ApiQueryConfigFileGroupsRequest {
	r.limit = &limit
	return r
}
// 命名空间，不填表示全部命名空间
func (r ApiQueryConfigFileGroupsRequest) Namespace(namespace string) ApiQueryConfigFileGroupsRequest {
	r.namespace = &namespace
	return r
}
// 配置文件分组名，模糊搜索
func (r ApiQueryConfigFileGroupsRequest) Group(group string) ApiQueryConfigFileGroupsRequest {
	r.group = &group
	return r
}
// 配置文件名称，模糊搜索
func (r ApiQueryConfigFileGroupsRequest) FileName(fileName string) ApiQueryConfigFileGroupsRequest {
	r.fileName = &fileName
	return r
}
// 翻页偏移量 默认为 0
func (r ApiQueryConfigFileGroupsRequest) Offset(offset int32) ApiQueryConfigFileGroupsRequest {
	r.offset = &offset
	return r
}

func (r ApiQueryConfigFileGroupsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.QueryConfigFileGroupsExecute(r)
}

/*
QueryConfigFileGroups 搜索配置文件组

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryConfigFileGroupsRequest
*/
func (a *ConfigConsoleApiService) QueryConfigFileGroups(ctx _context.Context) ApiQueryConfigFileGroupsRequest {
	return ApiQueryConfigFileGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigConsoleApiService) QueryConfigFileGroupsExecute(r ApiQueryConfigFileGroupsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigConsoleApiService.QueryConfigFileGroups")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/v1/configfilegroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.limit == nil {
		return nil, reportError("limit is required and must be specified")
	}

	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.group != nil {
		localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	}
	if r.fileName != nil {
		localVarQueryParams.Add("fileName", parameterToString(*r.fileName, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiQueryConfigFilesByGroupRequest struct {
	ctx _context.Context
	ApiService *ConfigConsoleApiService
	limit *int32
	namespace *string
	group *string
	offset *int32
}

// 一页大小，最大为 100
func (r ApiQueryConfigFilesByGroupRequest) Limit(limit int32) ApiQueryConfigFilesByGroupRequest {
	r.limit = &limit
	return r
}
// 命名空间
func (r ApiQueryConfigFilesByGroupRequest) Namespace(namespace string) ApiQueryConfigFilesByGroupRequest {
	r.namespace = &namespace
	return r
}
// 配置文件分组
func (r ApiQueryConfigFilesByGroupRequest) Group(group string) ApiQueryConfigFilesByGroupRequest {
	r.group = &group
	return r
}
// 翻页偏移量 默认为 0
func (r ApiQueryConfigFilesByGroupRequest) Offset(offset int32) ApiQueryConfigFilesByGroupRequest {
	r.offset = &offset
	return r
}

func (r ApiQueryConfigFilesByGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.QueryConfigFilesByGroupExecute(r)
}

/*
QueryConfigFilesByGroup 搜索配置文件

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryConfigFilesByGroupRequest
*/
func (a *ConfigConsoleApiService) QueryConfigFilesByGroup(ctx _context.Context) ApiQueryConfigFilesByGroupRequest {
	return ApiQueryConfigFilesByGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigConsoleApiService) QueryConfigFilesByGroupExecute(r ApiQueryConfigFilesByGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigConsoleApiService.QueryConfigFilesByGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/v1/configfiles/by-group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.limit == nil {
		return nil, reportError("limit is required and must be specified")
	}

	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.group != nil {
		localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSearchConfigFileRequest struct {
	ctx _context.Context
	ApiService *ConfigConsoleApiService
	limit *int32
	namespace *string
	group *string
	name *string
	tags *string
	offset *int32
}

// 一页大小，最大为 100
func (r ApiSearchConfigFileRequest) Limit(limit int32) ApiSearchConfigFileRequest {
	r.limit = &limit
	return r
}
// 命名空间
func (r ApiSearchConfigFileRequest) Namespace(namespace string) ApiSearchConfigFileRequest {
	r.namespace = &namespace
	return r
}
// 配置文件分组
func (r ApiSearchConfigFileRequest) Group(group string) ApiSearchConfigFileRequest {
	r.group = &group
	return r
}
// 配置文件
func (r ApiSearchConfigFileRequest) Name(name string) ApiSearchConfigFileRequest {
	r.name = &name
	return r
}
// 格式：key1,value1,key2,value2
func (r ApiSearchConfigFileRequest) Tags(tags string) ApiSearchConfigFileRequest {
	r.tags = &tags
	return r
}
// 翻页偏移量 默认为 0
func (r ApiSearchConfigFileRequest) Offset(offset int32) ApiSearchConfigFileRequest {
	r.offset = &offset
	return r
}

func (r ApiSearchConfigFileRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SearchConfigFileExecute(r)
}

/*
SearchConfigFile 搜索配置文件

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchConfigFileRequest
*/
func (a *ConfigConsoleApiService) SearchConfigFile(ctx _context.Context) ApiSearchConfigFileRequest {
	return ApiSearchConfigFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigConsoleApiService) SearchConfigFileExecute(r ApiSearchConfigFileRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigConsoleApiService.SearchConfigFile")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/v1/configfiles/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.limit == nil {
		return nil, reportError("limit is required and must be specified")
	}

	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.group != nil {
		localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateConfigFileRequest struct {
	ctx _context.Context
	ApiService *ConfigConsoleApiService
	body *V1ConfigFile
}

// 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header Header X-Polaris-Token: {访问凭据}  &#x60;&#x60;&#x60;{     \&quot;name\&quot;:\&quot;application.properties\&quot;,     \&quot;namespace\&quot;:\&quot;someNamespace\&quot;,     \&quot;group\&quot;:\&quot;someGroup\&quot;,     \&quot;content\&quot;:\&quot;redis.cache.age&#x3D;10\&quot;,     \&quot;comment\&quot;:\&quot;第一个配置文件\&quot;,     \&quot;tags\&quot;:[{\&quot;key\&quot;:\&quot;service\&quot;, \&quot;value\&quot;:\&quot;helloService\&quot;}],     \&quot;createBy\&quot;:\&quot;ledou\&quot;,     \&quot;format\&quot;:\&quot;properties\&quot; } &#x60;&#x60;&#x60; 
func (r ApiUpdateConfigFileRequest) Body(body V1ConfigFile) ApiUpdateConfigFileRequest {
	r.body = &body
	return r
}

func (r ApiUpdateConfigFileRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateConfigFileExecute(r)
}

/*
UpdateConfigFile 创建配置文件

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateConfigFileRequest
*/
func (a *ConfigConsoleApiService) UpdateConfigFile(ctx _context.Context) ApiUpdateConfigFileRequest {
	return ApiUpdateConfigFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigConsoleApiService) UpdateConfigFileExecute(r ApiUpdateConfigFileRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigConsoleApiService.UpdateConfigFile")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/v1/configfiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateConfigFileGroupRequest struct {
	ctx _context.Context
	ApiService *ConfigConsoleApiService
	body *V1ConfigFileGroup
}

// 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header Header X-Polaris-Token: {访问凭据}  &#x60;&#x60;&#x60; {     \&quot;name\&quot;:\&quot;someGroup\&quot;,     \&quot;namespace\&quot;:\&quot;someNamespace\&quot;,     \&quot;comment\&quot;:\&quot;some comment\&quot;,     \&quot;createBy\&quot;:\&quot;ledou\&quot; } &#x60;&#x60;&#x60;
func (r ApiUpdateConfigFileGroupRequest) Body(body V1ConfigFileGroup) ApiUpdateConfigFileGroupRequest {
	r.body = &body
	return r
}

func (r ApiUpdateConfigFileGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateConfigFileGroupExecute(r)
}

/*
UpdateConfigFileGroup 更新配置文件组

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateConfigFileGroupRequest
*/
func (a *ConfigConsoleApiService) UpdateConfigFileGroup(ctx _context.Context) ApiUpdateConfigFileGroupRequest {
	return ApiUpdateConfigFileGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ConfigConsoleApiService) UpdateConfigFileGroupExecute(r ApiUpdateConfigFileGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConfigConsoleApiService.UpdateConfigFileGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config/v1/configfilegroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
