/*
Polaris Server

一个支持多语言、多框架的云原生服务发现和治理中心  提供高性能SDK和无侵入Sidecar两种接入方式  

API version: v0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package polaris

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// NamespacesApiService NamespacesApi service
type NamespacesApiService service

type ApiCoreCreateNamespacesRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	body *[]V1Namespace
}

// create namespaces
func (r ApiCoreCreateNamespacesRequest) Body(body []V1Namespace) ApiCoreCreateNamespacesRequest {
	r.body = &body
	return r
}

func (r ApiCoreCreateNamespacesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CoreCreateNamespacesExecute(r)
}

/*
CoreCreateNamespaces 创建命名空间


| 参数名           | 类型     | 描述                                                       | 是否必填 |
| ---------------- | -------- | ---------------------------------------------------------- | -------- |
| name             | string   | 命名空间唯一名称                                           | 是       |
| comment          | string   | 描述                                                       | 否       |
| user_ids         | []string | 可以操作该资源的用户，**仅当开启北极星鉴权时生效**         | 否       |
| group_ids        | []string | 可以操作该资源的用户组，，**仅当开启北极星鉴权时生效**     | 否       |
| remove_user_ids  | []string | 被移除的可操作该资源的用户，**仅当开启北极星鉴权时生效**   | 否       |
| remove_group_ids | []string | 被移除的可操作该资源的用户组，**仅当开启北极星鉴权时生效** | 否       |


请求示例：

~~~
POST /{core|naming}/v1/namespaces

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

[
    {
        "name": "...",
        "comment": "..."
    }
]
~~~

应答示例：
~~~json
{
    "code":200000,
    "info":"...",
    "size":1,
    "responses":[
        {
            "code":200000,
            "info":"execute success",
            "namespace":{
                "name":"...",
                "token":"..."
            }
        }
    ]
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreCreateNamespacesRequest
*/
func (a *NamespacesApiService) CoreCreateNamespaces(ctx _context.Context) ApiCoreCreateNamespacesRequest {
	return ApiCoreCreateNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *NamespacesApiService) CoreCreateNamespacesExecute(r ApiCoreCreateNamespacesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.CoreCreateNamespaces")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core/v1/namespaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCoreDeleteNamespacesRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	body *[]V1Namespace
}

// delete namespaces
func (r ApiCoreDeleteNamespacesRequest) Body(body []V1Namespace) ApiCoreDeleteNamespacesRequest {
	r.body = &body
	return r
}

func (r ApiCoreDeleteNamespacesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CoreDeleteNamespacesExecute(r)
}

/*
CoreDeleteNamespaces 删除命名空间


| 参数名 | 类型   | 描述                          | 是否必填 |
| ------ | ------ | ----------------------------- | -------- |
| name   | string | 命名空间唯一名称              | 是       |
| token  | string | 命名空间的token，用于权限鉴定 | 是       |

请求示例：

~~~
POST /{core|naming}/v1/namespaces/delete

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

[
    {
        "name": "...",
    }
]
~~~

应答示例：
~~~json
{
    "code": 200000,
    "info": "execute success",
    "size": 0
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreDeleteNamespacesRequest
*/
func (a *NamespacesApiService) CoreDeleteNamespaces(ctx _context.Context) ApiCoreDeleteNamespacesRequest {
	return ApiCoreDeleteNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *NamespacesApiService) CoreDeleteNamespacesExecute(r ApiCoreDeleteNamespacesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.CoreDeleteNamespaces")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core/v1/namespaces/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCoreGetNamespaceTokenRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
}


func (r ApiCoreGetNamespaceTokenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CoreGetNamespaceTokenExecute(r)
}

/*
CoreGetNamespaceToken 查询命名空间Token

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreGetNamespaceTokenRequest

Deprecated
*/
func (a *NamespacesApiService) CoreGetNamespaceToken(ctx _context.Context) ApiCoreGetNamespaceTokenRequest {
	return ApiCoreGetNamespaceTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
// Deprecated
func (a *NamespacesApiService) CoreGetNamespaceTokenExecute(r ApiCoreGetNamespaceTokenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.CoreGetNamespaceToken")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core/v1/namespaces/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCoreGetNamespacesRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	name *string
	offset *int32
	limit *int32
}

// 命名空间唯一名称
func (r ApiCoreGetNamespacesRequest) Name(name string) ApiCoreGetNamespacesRequest {
	r.name = &name
	return r
}
// 查询偏移量
func (r ApiCoreGetNamespacesRequest) Offset(offset int32) ApiCoreGetNamespacesRequest {
	r.offset = &offset
	return r
}
// 查询条数，**最多查询100条**
func (r ApiCoreGetNamespacesRequest) Limit(limit int32) ApiCoreGetNamespacesRequest {
	r.limit = &limit
	return r
}

func (r ApiCoreGetNamespacesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CoreGetNamespacesExecute(r)
}

/*
CoreGetNamespaces 查询命名空间列表


| 参数名 | 类型   | 描述                                             | 是否必填 |
| ------ | ------ | ------------------------------------------------ | -------- |
| name   | string | 命名空间唯一名称                                 | 是       |
| offset | uint   | 查询偏移量                                       | 否       |
| limit  | uint   | 查询条数，**最多查询100条**                      | 否       |


请求示例：

~~~
GET /{core|naming}/v1/namespaces?name=&offset=&limit=

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}
~~~

应答示例：
~~~json
{
    "code": 200000,
    "info": "execute success",
    "amount": 0,
    "size": 3,
    "namespaces": [
        {
            "name": "...",
            "comment": "",
            "ctime": "2021-11-22 23:50:52",
            "mtime": "2021-11-22 23:50:52"
        },
        {
            "name": "...",
            "comment": "",
            "ctime": "2021-11-22 23:50:52",
            "mtime": "2021-11-22 23:50:52"
        }
    ]
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreGetNamespacesRequest
*/
func (a *NamespacesApiService) CoreGetNamespaces(ctx _context.Context) ApiCoreGetNamespacesRequest {
	return ApiCoreGetNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *NamespacesApiService) CoreGetNamespacesExecute(r ApiCoreGetNamespacesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.CoreGetNamespaces")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core/v1/namespaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.name == nil {
		return nil, reportError("name is required and must be specified")
	}

	localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCoreUpdateNamespaceTokenRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
}


func (r ApiCoreUpdateNamespaceTokenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CoreUpdateNamespaceTokenExecute(r)
}

/*
CoreUpdateNamespaceToken 更新命名空间Token

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreUpdateNamespaceTokenRequest

Deprecated
*/
func (a *NamespacesApiService) CoreUpdateNamespaceToken(ctx _context.Context) ApiCoreUpdateNamespaceTokenRequest {
	return ApiCoreUpdateNamespaceTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
// Deprecated
func (a *NamespacesApiService) CoreUpdateNamespaceTokenExecute(r ApiCoreUpdateNamespaceTokenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.CoreUpdateNamespaceToken")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core/v1/namespaces/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCoreUpdateNamespacesRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	body *[]V1Namespace
}

// update namespaces
func (r ApiCoreUpdateNamespacesRequest) Body(body []V1Namespace) ApiCoreUpdateNamespacesRequest {
	r.body = &body
	return r
}

func (r ApiCoreUpdateNamespacesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CoreUpdateNamespacesExecute(r)
}

/*
CoreUpdateNamespaces 更新命名空间


| 参数名           | 类型     | 描述                                                       | 是否必填 |
| ---------------- | -------- | ---------------------------------------------------------- | -------- |
| name             | string   | 命名空间唯一名称                                           | 是       |
| comment          | string   | 描述                                                       | 否       |
| token            | string   | 命名空间的token，用于权限鉴定                              | 是       |
| user_ids         | []string | 可以操作该资源的用户，**仅当开启北极星鉴权时生效**         | 否       |
| group_ids        | []string | 可以操作该资源的用户组，，**仅当开启北极星鉴权时生效**     | 否       |
| remove_user_ids  | []string | 被移除的可操作该资源的用户，**仅当开启北极星鉴权时生效**   | 否       |
| remove_group_ids | []string | 被移除的可操作该资源的用户组，**仅当开启北极星鉴权时生效** | 否       |

请求示例：

~~~
PUT /{core|naming}/v1/namespaces

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

[
    {
        "name": "...",
        "comment": "..."
    }
]
~~~

应答示例：
~~~json
{
    "code": 200000,
    "info": "execute success",
    "size": 0
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCoreUpdateNamespacesRequest
*/
func (a *NamespacesApiService) CoreUpdateNamespaces(ctx _context.Context) ApiCoreUpdateNamespacesRequest {
	return ApiCoreUpdateNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *NamespacesApiService) CoreUpdateNamespacesExecute(r ApiCoreUpdateNamespacesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.CoreUpdateNamespaces")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core/v1/namespaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateNamespacesRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	body *[]V1Namespace
}

// create namespaces
func (r ApiCreateNamespacesRequest) Body(body []V1Namespace) ApiCreateNamespacesRequest {
	r.body = &body
	return r
}

func (r ApiCreateNamespacesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateNamespacesExecute(r)
}

/*
CreateNamespaces 创建命名空间


| 参数名           | 类型     | 描述                                                       | 是否必填 |
| ---------------- | -------- | ---------------------------------------------------------- | -------- |
| name             | string   | 命名空间唯一名称                                           | 是       |
| comment          | string   | 描述                                                       | 否       |
| user_ids         | []string | 可以操作该资源的用户，**仅当开启北极星鉴权时生效**         | 否       |
| group_ids        | []string | 可以操作该资源的用户组，，**仅当开启北极星鉴权时生效**     | 否       |
| remove_user_ids  | []string | 被移除的可操作该资源的用户，**仅当开启北极星鉴权时生效**   | 否       |
| remove_group_ids | []string | 被移除的可操作该资源的用户组，**仅当开启北极星鉴权时生效** | 否       |


请求示例：

~~~
POST /naming/v1/namespaces

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

[
    {
        "name": "...",
        "comment": "..."
    }
]
~~~

应答示例：
~~~json
{
    "code":200000,
    "info":"...",
    "size":1,
    "responses":[
        {
            "code":200000,
            "info":"execute success",
            "namespace":{
                "name":"...",
                "token":"..."
            }
        }
    ]
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateNamespacesRequest
*/
func (a *NamespacesApiService) CreateNamespaces(ctx _context.Context) ApiCreateNamespacesRequest {
	return ApiCreateNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *NamespacesApiService) CreateNamespacesExecute(r ApiCreateNamespacesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.CreateNamespaces")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/namespaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteNamespacesRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	body *[]V1Namespace
}

// delete namespaces
func (r ApiDeleteNamespacesRequest) Body(body []V1Namespace) ApiDeleteNamespacesRequest {
	r.body = &body
	return r
}

func (r ApiDeleteNamespacesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteNamespacesExecute(r)
}

/*
DeleteNamespaces 删除命名空间


| 参数名 | 类型   | 描述                          | 是否必填 |
| ------ | ------ | ----------------------------- | -------- |
| name   | string | 命名空间唯一名称              | 是       |
| token  | string | 命名空间的token，用于权限鉴定 | 是       |

请求示例：

~~~
POST /naming/v1/namespaces/delete

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

[
    {
        "name": "...",
    }
]
~~~

应答示例：
~~~json
{
    "code": 200000,
    "info": "execute success",
    "size": 0
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteNamespacesRequest
*/
func (a *NamespacesApiService) DeleteNamespaces(ctx _context.Context) ApiDeleteNamespacesRequest {
	return ApiDeleteNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *NamespacesApiService) DeleteNamespacesExecute(r ApiDeleteNamespacesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.DeleteNamespaces")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/namespaces/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetNamespaceTokenRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
}


func (r ApiGetNamespaceTokenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetNamespaceTokenExecute(r)
}

/*
GetNamespaceToken 查询命名空间Token

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNamespaceTokenRequest

Deprecated
*/
func (a *NamespacesApiService) GetNamespaceToken(ctx _context.Context) ApiGetNamespaceTokenRequest {
	return ApiGetNamespaceTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
// Deprecated
func (a *NamespacesApiService) GetNamespaceTokenExecute(r ApiGetNamespaceTokenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetNamespaceToken")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/namespace/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetNamespacesRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	name *string
	offset *int32
	limit *int32
}

// 命名空间唯一名称
func (r ApiGetNamespacesRequest) Name(name string) ApiGetNamespacesRequest {
	r.name = &name
	return r
}
// 查询偏移量
func (r ApiGetNamespacesRequest) Offset(offset int32) ApiGetNamespacesRequest {
	r.offset = &offset
	return r
}
// 查询条数，**最多查询100条**
func (r ApiGetNamespacesRequest) Limit(limit int32) ApiGetNamespacesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetNamespacesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetNamespacesExecute(r)
}

/*
GetNamespaces 获取命名空间列表



| 参数名 | 类型   | 描述                                             | 是否必填 |
| ------ | ------ | ------------------------------------------------ | -------- |
| name   | string | 命名空间唯一名称                                 | 是       |
| offset | uint   | 查询偏移量                                       | 否       |
| limit  | uint   | 查询条数，**最多查询100条**                      | 否       |


请求示例：

~~~
GET /naming/v1/namespaces?name=&offset=&limit=

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}
~~~

应答示例：
~~~json
{
    "code": 200000,
    "info": "execute success",
    "amount": 0,
    "size": 3,
    "namespaces": [
        {
            "name": "...",
            "comment": "",
            "ctime": "2021-11-22 23:50:52",
            "mtime": "2021-11-22 23:50:52"
        },
        {
            "name": "...",
            "comment": "",
            "ctime": "2021-11-22 23:50:52",
            "mtime": "2021-11-22 23:50:52"
        }
    ]
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNamespacesRequest
*/
func (a *NamespacesApiService) GetNamespaces(ctx _context.Context) ApiGetNamespacesRequest {
	return ApiGetNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *NamespacesApiService) GetNamespacesExecute(r ApiGetNamespacesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.GetNamespaces")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/namespaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.name == nil {
		return nil, reportError("name is required and must be specified")
	}

	localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateNamespaceTokenRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
}


func (r ApiUpdateNamespaceTokenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateNamespaceTokenExecute(r)
}

/*
UpdateNamespaceToken 更新命名空间Token

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateNamespaceTokenRequest

Deprecated
*/
func (a *NamespacesApiService) UpdateNamespaceToken(ctx _context.Context) ApiUpdateNamespaceTokenRequest {
	return ApiUpdateNamespaceTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
// Deprecated
func (a *NamespacesApiService) UpdateNamespaceTokenExecute(r ApiUpdateNamespaceTokenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.UpdateNamespaceToken")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/namespace/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateNamespacesRequest struct {
	ctx _context.Context
	ApiService *NamespacesApiService
	body *[]V1Namespace
}

// update namespaces
func (r ApiUpdateNamespacesRequest) Body(body []V1Namespace) ApiUpdateNamespacesRequest {
	r.body = &body
	return r
}

func (r ApiUpdateNamespacesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateNamespacesExecute(r)
}

/*
UpdateNamespaces 更新命名空间


| 参数名           | 类型     | 描述                                                       | 是否必填 |
| ---------------- | -------- | ---------------------------------------------------------- | -------- |
| name             | string   | 命名空间唯一名称                                           | 是       |
| comment          | string   | 描述                                                       | 否       |
| token            | string   | 命名空间的token，用于权限鉴定                              | 是       |
| user_ids         | []string | 可以操作该资源的用户，**仅当开启北极星鉴权时生效**         | 否       |
| group_ids        | []string | 可以操作该资源的用户组，，**仅当开启北极星鉴权时生效**     | 否       |
| remove_user_ids  | []string | 被移除的可操作该资源的用户，**仅当开启北极星鉴权时生效**   | 否       |
| remove_group_ids | []string | 被移除的可操作该资源的用户组，**仅当开启北极星鉴权时生效** | 否       |

请求示例：

~~~
PUT /naming/v1/namespaces

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

[
    {
        "name": "...",
        "comment": "..."
    }
]
~~~

应答示例：
~~~json
{
    "code": 200000,
    "info": "execute success",
    "size": 0
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateNamespacesRequest
*/
func (a *NamespacesApiService) UpdateNamespaces(ctx _context.Context) ApiUpdateNamespacesRequest {
	return ApiUpdateNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *NamespacesApiService) UpdateNamespacesExecute(r ApiUpdateNamespacesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NamespacesApiService.UpdateNamespaces")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/namespaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
