/*
Polaris Server

一个支持多语言、多框架的云原生服务发现和治理中心  提供高性能SDK和无侵入Sidecar两种接入方式  

API version: v0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package polaris

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// UserGroupApiService UserGroupApi service
type UserGroupApiService service

type ApiCreateGroupRequest struct {
	ctx _context.Context
	ApiService *UserGroupApiService
	body *V1UserGroup
}

// create group
func (r ApiCreateGroupRequest) Body(body V1UserGroup) ApiCreateGroupRequest {
	r.body = &body
	return r
}

func (r ApiCreateGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateGroupExecute(r)
}

/*
CreateGroup 创建用户组


请求示例：

~~~
POST /core/v1/usergroup
Header X-Polaris-Token: {访问凭据}
~~~

~~~json
{
	"name": "GROUP_1",
	"comment": "",
	"relation": {
		"users": [
			{
				"id": "xxx"
			}, {
				"id": "xxx"
			}
		]
	}
}
~~~

| 参数名   | 类型     | 描述                   |
|----------|----------|----------------------|
| name     | string   | 用户组名称             |
| comment  | string   | 用户组备注信息         |
| relation | user列表 | 当前用户组关联的用户ID |

响应示例：

~~~json
{
	"code": 200000,
	"info": "execute success"
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGroupRequest
*/
func (a *UserGroupApiService) CreateGroup(ctx _context.Context) ApiCreateGroupRequest {
	return ApiCreateGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UserGroupApiService) CreateGroupExecute(r ApiCreateGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserGroupApiService.CreateGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core/v1/usergroup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteGroupsRequest struct {
	ctx _context.Context
	ApiService *UserGroupApiService
	body *V1UserGroup
}

// delete group
func (r ApiDeleteGroupsRequest) Body(body V1UserGroup) ApiDeleteGroupsRequest {
	r.body = &body
	return r
}

func (r ApiDeleteGroupsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteGroupsExecute(r)
}

/*
DeleteGroups 删除用户组


请求示例：

~~~
POST /core/v1/usergroups/delete
Header X-Polaris-Token: {访问凭据}
~~~

~~~json
[
	{
		"id": "xxx"
	}
]
~~~

响应示例：

~~~json
{
	"code": 200000,
	"info": "execute success",
	"responses": [
		{
			"code": 200000,
			"info": "execute success"
		}
	]
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteGroupsRequest
*/
func (a *UserGroupApiService) DeleteGroups(ctx _context.Context) ApiDeleteGroupsRequest {
	return ApiDeleteGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UserGroupApiService) DeleteGroupsExecute(r ApiDeleteGroupsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserGroupApiService.DeleteGroups")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core/v1/usergroups/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetGroupRequest struct {
	ctx _context.Context
	ApiService *UserGroupApiService
	id *int32
}

// 用户组ID
func (r ApiGetGroupRequest) Id(id int32) ApiGetGroupRequest {
	r.id = &id
	return r
}

func (r ApiGetGroupRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetGroupExecute(r)
}

/*
GetGroup 获取用户组详情


请求示例：

~~~
GET /core/v1/usergroup/detail?id=xxx
Header X-Polaris-Token: {访问凭据}
~~~


响应示例：

~~~json
{
	"code": 200000,
	"info": "execute success",
	"userGroup": {
		"id": "xxx",
		"name": "xxx",
		"token_enable": true,
		"comment": "",
		"ctime": "2022-02-09 21:46:33",
		"mtime": "2022-02-09 21:46:33",
		"relation": {
		"users": [
				{
					"id": "xxx",
					"name": "xxx",
					"source": "",
					"token_enable": true,
					"comment": "",
					"ctime": "2022-02-09 19:48:53",
					"mtime": "2022-02-09 19:48:53",
				}
			]
		},
		"user_count": 1
	}
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGroupRequest
*/
func (a *UserGroupApiService) GetGroup(ctx _context.Context) ApiGetGroupRequest {
	return ApiGetGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UserGroupApiService) GetGroupExecute(r ApiGetGroupRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserGroupApiService.GetGroup")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core/v1/usergroup/detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.id == nil {
		return nil, reportError("id is required and must be specified")
	}

	localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetGroupTokenRequest struct {
	ctx _context.Context
	ApiService *UserGroupApiService
	id *int32
}

// 用户组ID
func (r ApiGetGroupTokenRequest) Id(id int32) ApiGetGroupTokenRequest {
	r.id = &id
	return r
}

func (r ApiGetGroupTokenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetGroupTokenExecute(r)
}

/*
GetGroupToken 获取用户组 token


请求示例：

~~~
GET /core/v1/usergroup/token?id=xxx
Header X-Polaris-Token: {访问凭据}
~~~

响应示例：

~~~json
{
	"code": 200000,
	"info": "execute success",
	"userGroup": {
		"id": "xxx",
		"auth_token": "xxx",
		"token_enable": true
	}
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGroupTokenRequest
*/
func (a *UserGroupApiService) GetGroupToken(ctx _context.Context) ApiGetGroupTokenRequest {
	return ApiGetGroupTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UserGroupApiService) GetGroupTokenExecute(r ApiGetGroupTokenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserGroupApiService.GetGroupToken")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core/v1/usergroup/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.id == nil {
		return nil, reportError("id is required and must be specified")
	}

	localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetGroupsRequest struct {
	ctx _context.Context
	ApiService *UserGroupApiService
	id *string
	name *string
	userId *string
	offset *int32
	limit *int32
}

// 用户组ID
func (r ApiGetGroupsRequest) Id(id string) ApiGetGroupsRequest {
	r.id = &id
	return r
}
// 用户组名称, 当前仅提供全模糊搜索
func (r ApiGetGroupsRequest) Name(name string) ApiGetGroupsRequest {
	r.name = &name
	return r
}
// 用户ID, 用于查询某个用户关联的用户组列表
func (r ApiGetGroupsRequest) UserId(userId string) ApiGetGroupsRequest {
	r.userId = &userId
	return r
}
// 查询偏移量, 默认为0
func (r ApiGetGroupsRequest) Offset(offset int32) ApiGetGroupsRequest {
	r.offset = &offset
	return r
}
// 本次查询条数, 最大为100
func (r ApiGetGroupsRequest) Limit(limit int32) ApiGetGroupsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetGroupsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetGroupsExecute(r)
}

/*
GetGroups 查询用户组列表


请求示例：

~~~
GET /core/v1/usergroups?{key}={value}
Header X-Polaris-Token: {访问凭据}
~~~

支持的URL参数

| 参数名  | 类型   | 描述                                     | 是否必填 |
|---------|--------|----------------------------------------|---------|
| id      | string | 用户组ID                                 | 否       |
| name    | string | 用户组名称, 当前仅提供全模糊搜索         | 否       |
| user_id | string | 用户ID, 用于查询某个用户关联的用户组列表 | 否       |
| offset  | int    | 查询偏移量, 默认为0                      | 否       |
| limit   | int    | 本次查询条数, 最大为100                  | 否       |


响应示例：

~~~json
{
	"code": 200000,
	"info": "execute success",
	"amount": 1,
	"size": 1,
	"userGroups": [
		{
			"id": "xxx",
			"name": "xxx",
			"auth_token": null,
			"token_enable": true,
			"comment": "",
			"ctime": "2022-02-09 21:46:33",
			"mtime": "2022-02-09 21:46:33",
			"user_count": 1
		}
	]
}
~~~

数据结构：

> userGroups

| 参数名       | 类型   | 描述                   |
|--------------|--------|----------------------|
| id           | string | 用户组ID               |
| name         | string | 用户组名称             |
| auth_token   | string | 用户组访问凭据         |
| token_enable | bool   | 用户组访问凭据是否可用 |
| comment      | string | 用户组备注信息         |
| ctime        | string | 用户组创建时间         |
| mtime        | string | 用户组修改时间         |
| user_count   | int    | 当前用户组下用户的数量 |


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGroupsRequest
*/
func (a *UserGroupApiService) GetGroups(ctx _context.Context) ApiGetGroupsRequest {
	return ApiGetGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UserGroupApiService) GetGroupsExecute(r ApiGetGroupsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserGroupApiService.GetGroups")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core/v1/usergroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("user_id", parameterToString(*r.userId, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiResetGroupTokenRequest struct {
	ctx _context.Context
	ApiService *UserGroupApiService
	body *V1UserGroup
}

// reset user group token
func (r ApiResetGroupTokenRequest) Body(body V1UserGroup) ApiResetGroupTokenRequest {
	r.body = &body
	return r
}

func (r ApiResetGroupTokenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ResetGroupTokenExecute(r)
}

/*
ResetGroupToken 重置用户组 token


请求示例：

~~~
PUT /core/v1/usergroup/token/refresh
Header X-Polaris-Token: {访问凭据}
~~~

~~~json
{
	"id": "xxx"
}
~~~

响应示例：

~~~json
{
	"code": 200000,
	"info": "execute success"
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiResetGroupTokenRequest
*/
func (a *UserGroupApiService) ResetGroupToken(ctx _context.Context) ApiResetGroupTokenRequest {
	return ApiResetGroupTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UserGroupApiService) ResetGroupTokenExecute(r ApiResetGroupTokenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserGroupApiService.ResetGroupToken")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core/v1/usergroup/token/refresh"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateGroupTokenRequest struct {
	ctx _context.Context
	ApiService *UserGroupApiService
	body *V1UserGroup
}

// update user group token
func (r ApiUpdateGroupTokenRequest) Body(body V1UserGroup) ApiUpdateGroupTokenRequest {
	r.body = &body
	return r
}

func (r ApiUpdateGroupTokenRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateGroupTokenExecute(r)
}

/*
UpdateGroupToken 更新用户组 token


请求示例：

~~~
PUT /core/v1/usergroup/token/status
Header X-Polaris-Token: {访问凭据}
~~~

~~~json
{
	"id": "xxx",
	"token_enable": false
}
~~~

响应示例：

~~~json
{
	"code": 200000,
	"info": "execute success"
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateGroupTokenRequest
*/
func (a *UserGroupApiService) UpdateGroupToken(ctx _context.Context) ApiUpdateGroupTokenRequest {
	return ApiUpdateGroupTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UserGroupApiService) UpdateGroupTokenExecute(r ApiUpdateGroupTokenRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserGroupApiService.UpdateGroupToken")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core/v1/usergroup/token/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateGroupsRequest struct {
	ctx _context.Context
	ApiService *UserGroupApiService
	body *V1UserGroup
}

// update group
func (r ApiUpdateGroupsRequest) Body(body V1UserGroup) ApiUpdateGroupsRequest {
	r.body = &body
	return r
}

func (r ApiUpdateGroupsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateGroupsExecute(r)
}

/*
UpdateGroups 更新用户组


请求示例：

~~~
PUT /core/v1/usergroup
Header X-Polaris-Token: {访问凭据}
~~~

~~~json
[
	{
		"id": "xxx",
		"comment": "xxx",
		"add_relations": {
			"users": [{
				"id": "xxx"
			}, {
				"id": "xxx"
			}]
		},
		"remove_relations": {
			"users": [{
				"id": "xxx"
			}, {
				"id": "xxx"
			}]
		}
	}
]
~~~

| 参数名          | 类型     | 描述                       |
|-----------------|----------|--------------------------|
| id              | string   | 用户组ID                   |
| comment         | string   | 用户组备注信息             |
| add_relation    | user列表 | 当前用户组追加关联的用户ID |
| remove_relation | user列表 | 当前用户组移除关联的用户ID |

响应示例：

~~~json
{
	"code": 200000,
	"info": "execute success",
	"size": 1,
	"responses": [
		{
			"code": 200000,
			"info": "execute success"
		}
	]
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateGroupsRequest
*/
func (a *UserGroupApiService) UpdateGroups(ctx _context.Context) ApiUpdateGroupsRequest {
	return ApiUpdateGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UserGroupApiService) UpdateGroupsExecute(r ApiUpdateGroupsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserGroupApiService.UpdateGroups")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core/v1/usergroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
