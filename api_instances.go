/*
Polaris Server

一个支持多语言、多框架的云原生服务发现和治理中心  提供高性能SDK和无侵入Sidecar两种接入方式  

API version: v0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package polaris

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// InstancesApiService InstancesApi service
type InstancesApiService service

type ApiCreateInstancesRequest struct {
	ctx _context.Context
	ApiService *InstancesApiService
	body *[]V1Instance
}

// create instances
func (r ApiCreateInstancesRequest) Body(body []V1Instance) ApiCreateInstancesRequest {
	r.body = &body
	return r
}

func (r ApiCreateInstancesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateInstancesExecute(r)
}

/*
CreateInstances 创建实例


请求示例：

~~~
POST /naming/v1/instances

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

[
    {
    "service": "tdsql-ops-server",
    "namespace": "default",
    "host": "127.0.0.1",
    "port": 8080,
    "location": {
        "region": "ap-guangzhou",
        "zone": "ap-guangzhou-3",
        "campus": ""
    },
    "enable_health_check": true,
    "health_check": {
        "type": 1,
        "heartbeat": {
            "ttl": 10
        }
    },
    "metadata": {
        "env": "pre"
    }
}
]
~~~

应答示例：

~~~json
{
    "code": 200000,
    "info": "execute success",
    "size": 1,
    "responses": [
        {
            "code": 200000,
            "info": "execute success",
            "instance": {
                "id": "...",
                "service": "...",
                "namespace": "...",
                "host": "...",
                "port": 8080
            }
        }
    ]
}
~~~

数据结构：

> HealthCheck 参数

| 参数名    | 类型         | 描述                        | 是否必填 |
| --------- | ------------ | --------------------------- | -------- |
| type      | int          | 0(Unknow)/1(Heartbeat)      | 是       |
| heartbeat | {"ttl": int} | 心跳间隔(范围为区间(0, 60]) | 是       |

> Location 参数

| 参数名 | 类型   | 描述 | 是否必填 |
| ------ | ------ | ---- | -------- |
| region | string | 地区 | 否       |
| zone   | string | 地域 | 否       |
| campus | string | 园区 | 否       |

> 主请求参数

| 参数名              | 类型               | 描述                                                              | 是否必填 |
| ------------------- | ------------------ | ----------------------------------------------------------------- | -------- |
| service             | string             | 服务名                                                            | 是       |
| namespace           | string             | 命名空间                                                          | 是       |
| host                | string             | 实例的IP                                                          | 是       |
| port                | string             | 实例的端口                                                        | 是       |
| vpc_id              | string             | VPC ID                                                            | 否       |
| protocol            | string             | 对应端口的协议                                                    | 否       |
| version             | string             | 版本                                                              | 否       |
| priority            | string             | 优先级                                                            | 否       |
| weight              | string             | 权重(默认值100)                                                   | 是       |
| enable_health_check | bool               | 是否开启健康检查                                                  | 是       |
| health_check        | HealthCheck        | 健康检查类别具体描述信息(如果enable_health_check==true，必须填写) | 否       |
| healthy             | bool               | 实例健康标志(默认为健康的)                                        | 是       |
| isolate             | bool               | 实例隔离标志(默认为不隔离的)                                      | 是       |
| location            | Location           | 实例位置信息                                                      | 是       |
| metadata            | map<string,string> | 实例标签信息，最多只能存储64对 *key-value*                         | 否       |
| service_token       | string             | service的token信息                                                | 是       |


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateInstancesRequest
*/
func (a *InstancesApiService) CreateInstances(ctx _context.Context) ApiCreateInstancesRequest {
	return ApiCreateInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *InstancesApiService) CreateInstancesExecute(r ApiCreateInstancesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstancesApiService.CreateInstances")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteInstancesRequest struct {
	ctx _context.Context
	ApiService *InstancesApiService
	body *[]V1Instance
}

// delete instances
func (r ApiDeleteInstancesRequest) Body(body []V1Instance) ApiDeleteInstancesRequest {
	r.body = &body
	return r
}

func (r ApiDeleteInstancesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteInstancesExecute(r)
}

/*
DeleteInstances 删除实例(根据实例ID)


请求示例：

~~~
POST /naming/v1/instances/delete

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

[
    {
        "id": "...",
    }
]
~~~

应答示例：

~~~json
{
    "code": 200000,
    "info": "execute success",
    "amount": 0,
    "size": 0
}
~~~

数据结构：

| 参数名    | 类型   | 描述     | 是否必填 |
| --------- | ------ | -------- | -------- |
| id        | string | 实例ID   | 是       |
| service   | string | 服务名称 | 是       |
| namespace | string | 命名空间 | 是       |


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteInstancesRequest
*/
func (a *InstancesApiService) DeleteInstances(ctx _context.Context) ApiDeleteInstancesRequest {
	return ApiDeleteInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *InstancesApiService) DeleteInstancesExecute(r ApiDeleteInstancesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstancesApiService.DeleteInstances")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/instances/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteInstancesByHostRequest struct {
	ctx _context.Context
	ApiService *InstancesApiService
	body *[]V1Instance
}

// delete instances
func (r ApiDeleteInstancesByHostRequest) Body(body []V1Instance) ApiDeleteInstancesByHostRequest {
	r.body = &body
	return r
}

func (r ApiDeleteInstancesByHostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteInstancesByHostExecute(r)
}

/*
DeleteInstancesByHost 删除实例(根据主机)


请求示例：

~~~
POST /naming/v1/instances/delete

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

[
    {
        "host": "...",
    }
]
~~~

应答示例：

~~~json
{
    "code": 200000,
    "info": "execute success",
    "amount": 0,
    "size": 0
}
~~~

数据结构：

| 参数名    | 类型   | 描述     | 是否必填 |
| --------- | ------ | -------- | -------- |
| id        | string | 实例ID   | 是       |
| service   | string | 服务名称 | 是       |
| namespace | string | 命名空间 | 是       |


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteInstancesByHostRequest
*/
func (a *InstancesApiService) DeleteInstancesByHost(ctx _context.Context) ApiDeleteInstancesByHostRequest {
	return ApiDeleteInstancesByHostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *InstancesApiService) DeleteInstancesByHostExecute(r ApiDeleteInstancesByHostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstancesApiService.DeleteInstancesByHost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/instances/delete/host"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetInstanceLabelsRequest struct {
	ctx _context.Context
	ApiService *InstancesApiService
	service *string
	namespace *string
}

// 服务名称
func (r ApiGetInstanceLabelsRequest) Service(service string) ApiGetInstanceLabelsRequest {
	r.service = &service
	return r
}
// 命名空间
func (r ApiGetInstanceLabelsRequest) Namespace(namespace string) ApiGetInstanceLabelsRequest {
	r.namespace = &namespace
	return r
}

func (r ApiGetInstanceLabelsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetInstanceLabelsExecute(r)
}

/*
GetInstanceLabels 查询某个服务下所有实例的标签信息


请求示例：
~~~
GET /naming/v1/instances/labels?service=&namespace=&{参数key}={参数值}

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

~~~

返回示例：
~~~json
{
  "code": 200000,
  "info": "execute success",
  "client": null,
  "namespace": null,
  "service": null,
  "instance": null,
  "routing": null,
  "alias": null,
  "rateLimit": null,
  "circuitBreaker": null,
  "configRelease": null,
  "platform": null,
  "user": null,
  "userGroup": null,
  "authStrategy": null,
  "relation": null,
  "loginResponse": null,
  "modifyAuthStrategy": null,
  "modifyUserGroup": null,
  "resources": null,
  "optionSwitch": null,
  "instanceLabels": {
    "labels": {
      "campus": {
        "values": [
          ""
        ]
      },
      "region": {
        "values": [
          ""
        ]
      },
      "zone": {
        "values": [
          ""
        ]
      }
    }
  }
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetInstanceLabelsRequest
*/
func (a *InstancesApiService) GetInstanceLabels(ctx _context.Context) ApiGetInstanceLabelsRequest {
	return ApiGetInstanceLabelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *InstancesApiService) GetInstanceLabelsExecute(r ApiGetInstanceLabelsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstancesApiService.GetInstanceLabels")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/instances/labels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.service == nil {
		return nil, reportError("service is required and must be specified")
	}
	if r.namespace == nil {
		return nil, reportError("namespace is required and must be specified")
	}

	localVarQueryParams.Add("service", parameterToString(*r.service, ""))
	localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetInstancesRequest struct {
	ctx _context.Context
	ApiService *InstancesApiService
	service string
	namespace string
	host string
	keys string
	values string
	healthy string
	isolate string
	protocol string
	version string
	cmdbRegion string
	cmdbZone string
	cmdbIdc string
	offset int32
	limit int32
}


func (r ApiGetInstancesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetInstancesExecute(r)
}

/*
GetInstances 查询服务实例


请求示例

~~~
GET /naming/v1/instances?service=&namespace=&{参数key}={参数值}

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

~~~

| 参数名      | 类型   | 描述             | 是否必填                                                             |
| ----------- | ------ | ---------------- | -------------------------------------------------------------------- |
| service     | string | 服务名称         | 是                                                                   |
| namespace   | string | 命名空间         | 是                                                                   |
| host        | string | 实例IP           | 是(要么（service，namespace）存在，要么host存在，不然视为参数不完整) |
| port        | uint   | 实例端口         | 否                                                                   |
| keys        | string | 标签key          | 只允许填写一个key                                                    |
| values      | string | 标签value        | 只允许填写一个value                                                  |
| healthy     | string | 实例健康状态     | 否                                                                   |
| isolate     | string | 实例隔离状态     | 否                                                                   |
| protocol    | string | 实例端口协议状态 | 否                                                                   |
| version     | string | 实例版本         | 否                                                                   |
| cmdb_region | string | 实例region信息   | 否                                                                   |
| cmdb_zone   | string | 实例zone信息     | 否                                                                   |
| cmdb_idc    | string | 实例idc信息      | 否                                                                   |
| offset      | uint   | 查询偏移量       | 否                                                                   |
| limit       | uint   | 查询条数         | 否                                                                   |

应答示例：
~~~json
{
    "code": 200000,
    "info": "execute success",
    "amount": 1,
    "size": 1,
    "instances": [
        {
            "id": "...",
            "host": "...",
            "port": 8080,
            "weight": 100,
            "enableHealthCheck": true,
            "healthCheck": {
                "type": "HEARTBEAT",
                "heartbeat": {
                    "ttl": 10
                }
            },
            "healthy": true,
            "isolate": false,
            "location": {
                "region": "ap-guangzhou",
                "zone": "ap-guangzhou-3",
                "campus": ""
            },
            "metadata": {
                "env": "pre"
            },
            "ctime": "2021-11-23 01:59:31",
            "mtime": "2021-11-23 01:59:31",
            "revision": "..."
        }
    ]
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service 服务名称
 @param namespace 命名空间
 @param host 实例IP
 @param keys 标签key
 @param values 标签value
 @param healthy 实例健康状态
 @param isolate 实例隔离状态
 @param protocol 实例端口协议状态
 @param version 实例版本
 @param cmdbRegion 实例region信息
 @param cmdbZone 实例zone信息
 @param cmdbIdc 实例idc信息
 @param offset 查询偏移量
 @param limit 查询条数
 @return ApiGetInstancesRequest
*/
func (a *InstancesApiService) GetInstances(ctx _context.Context, service string, namespace string, host string, keys string, values string, healthy string, isolate string, protocol string, version string, cmdbRegion string, cmdbZone string, cmdbIdc string, offset int32, limit int32) ApiGetInstancesRequest {
	return ApiGetInstancesRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		namespace: namespace,
		host: host,
		keys: keys,
		values: values,
		healthy: healthy,
		isolate: isolate,
		protocol: protocol,
		version: version,
		cmdbRegion: cmdbRegion,
		cmdbZone: cmdbZone,
		cmdbIdc: cmdbIdc,
		offset: offset,
		limit: limit,
	}
}

// Execute executes the request
func (a *InstancesApiService) GetInstancesExecute(r ApiGetInstancesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstancesApiService.GetInstances")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", _neturl.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"host"+"}", _neturl.PathEscape(parameterToString(r.host, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keys"+"}", _neturl.PathEscape(parameterToString(r.keys, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"values"+"}", _neturl.PathEscape(parameterToString(r.values, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"healthy"+"}", _neturl.PathEscape(parameterToString(r.healthy, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"isolate"+"}", _neturl.PathEscape(parameterToString(r.isolate, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"protocol"+"}", _neturl.PathEscape(parameterToString(r.protocol, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", _neturl.PathEscape(parameterToString(r.version, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cmdb_region"+"}", _neturl.PathEscape(parameterToString(r.cmdbRegion, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cmdb_zone"+"}", _neturl.PathEscape(parameterToString(r.cmdbZone, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cmdb_idc"+"}", _neturl.PathEscape(parameterToString(r.cmdbIdc, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"offset"+"}", _neturl.PathEscape(parameterToString(r.offset, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"limit"+"}", _neturl.PathEscape(parameterToString(r.limit, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetInstancesCountRequest struct {
	ctx _context.Context
	ApiService *InstancesApiService
}


func (r ApiGetInstancesCountRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetInstancesCountExecute(r)
}

/*
GetInstancesCount 查询服务实例数量


请求示例：
~~~
GET /naming/v1/instances/count

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

~~~

返回示例：
~~~json
{
	"code": 200000,
	"info": "execute success",
	"amount": 97,
	"size": 0,
	"namespaces": [],
	"services": [],
	"instances": [],
	"routings": [],
	"aliases": [],
	"rateLimits": [],
	"configWithServices": [],
	"platforms": [],
	"users": [],
	"userGroups": [],
	"authStrategies": [],
	"clients": []
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetInstancesCountRequest
*/
func (a *InstancesApiService) GetInstancesCount(ctx _context.Context) ApiGetInstancesCountRequest {
	return ApiGetInstancesCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *InstancesApiService) GetInstancesCountExecute(r ApiGetInstancesCountRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstancesApiService.GetInstancesCount")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/instances/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateInstancesRequest struct {
	ctx _context.Context
	ApiService *InstancesApiService
	body *[]V1Instance
}

// update instances
func (r ApiUpdateInstancesRequest) Body(body []V1Instance) ApiUpdateInstancesRequest {
	r.body = &body
	return r
}

func (r ApiUpdateInstancesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateInstancesExecute(r)
}

/*
UpdateInstances 更新实例


请求示例：

~~~
PUT /naming/v1/instances

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

[
    {
    "service": "tdsql-ops-server",
    "namespace": "default",
    "host": "127.0.0.1",
    "port": 8080,
    "location": {
        "region": "ap-guangzhou",
        "zone": "ap-guangzhou-3",
        "campus": ""
    },
    "enable_health_check": true,
    "health_check": {
        "type": 1,
        "heartbeat": {
            "ttl": 10
        }
    },
    "metadata": {
        "env": "pre"
    }
}
]
~~~

应答示例：

~~~json
{
    "code": 200000,
    "info": "execute success",
    "amount": 0,
    "size": 0
}
~~~

数据结构：

> HealthCheck 参数

| 参数名    | 类型         | 描述                        | 是否必填 |
| --------- | ------------ | --------------------------- | -------- |
| type      | int          | 0(Unknow)/1(Heartbeat)      | 是       |
| heartbeat | {"ttl": int} | 心跳间隔(范围为区间(0, 60]) | 是       |

> Location 参数

| 参数名 | 类型   | 描述 | 是否必填 |
| ------ | ------ | ---- | -------- |
| region | string | 地区 | 否       |
| zone   | string | 地域 | 否       |
| campus | string | 园区 | 否       |

> 主请求参数

| 参数名              | 类型               | 描述                                                              | 是否必填 |
| ------------------- | ------------------ | ----------------------------------------------------------------- | -------- |
| service             | string             | 服务名                                                            | 是       |
| namespace           | string             | 命名空间                                                          | 是       |
| host                | string             | 实例的IP                                                          | 是       |
| port                | string             | 实例的端口                                                        | 是       |
| vpc_id              | string             | VPC ID                                                            | 否       |
| protocol            | string             | 对应端口的协议                                                    | 否       |
| version             | string             | 版本                                                              | 否       |
| priority            | string             | 优先级                                                            | 否       |
| weight              | string             | 权重(默认值100)                                                   | 是       |
| enable_health_check | bool               | 是否开启健康检查                                                  | 是       |
| health_check        | HealthCheck        | 健康检查类别具体描述信息(如果enable_health_check==true，必须填写) | 否       |
| healthy             | bool               | 实例健康标志(默认为健康的)                                        | 是       |
| isolate             | bool               | 实例隔离标志(默认为不隔离的)                                      | 是       |
| location            | Location           | 实例位置信息                                                      | 是       |
| metadata            | map<string,string> | 实例标签信息，最多只能存储64对 *key-value*                         | 否       |
| service_token       | string             | service的token信息                                                | 是       |


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateInstancesRequest
*/
func (a *InstancesApiService) UpdateInstances(ctx _context.Context) ApiUpdateInstancesRequest {
	return ApiUpdateInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *InstancesApiService) UpdateInstancesExecute(r ApiUpdateInstancesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstancesApiService.UpdateInstances")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateInstancesIsolateRequest struct {
	ctx _context.Context
	ApiService *InstancesApiService
	body *[]V1Instance
}

// update instances
func (r ApiUpdateInstancesIsolateRequest) Body(body []V1Instance) ApiUpdateInstancesIsolateRequest {
	r.body = &body
	return r
}

func (r ApiUpdateInstancesIsolateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateInstancesIsolateExecute(r)
}

/*
UpdateInstancesIsolate 修改服务实例的隔离状态


请求示例：

~~~
PUT /instances/isolate/host

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

[
    {
    "service": "tdsql-ops-server",
    "namespace": "default",
    "host": "127.0.0.1",
    "port": 8080,
    "location": {
        "region": "ap-guangzhou",
        "zone": "ap-guangzhou-3",
        "campus": ""
    },
    "enable_health_check": true,
    "health_check": {
        "type": 1,
        "heartbeat": {
            "ttl": 10
        }
    },
    "metadata": {
        "env": "pre"
    }
}
]
~~~

应答示例：

~~~json
{
    "code": 200000,
    "info": "execute success",
    "amount": 0,
    "size": 0
}
~~~

数据结构：

> HealthCheck 参数

| 参数名    | 类型         | 描述                        | 是否必填 |
| --------- | ------------ | --------------------------- | -------- |
| type      | int          | 0(Unknow)/1(Heartbeat)      | 是       |
| heartbeat | {"ttl": int} | 心跳间隔(范围为区间(0, 60]) | 是       |

> Location 参数

| 参数名 | 类型   | 描述 | 是否必填 |
| ------ | ------ | ---- | -------- |
| region | string | 地区 | 否       |
| zone   | string | 地域 | 否       |
| campus | string | 园区 | 否       |

> 主请求参数

| 参数名              | 类型               | 描述                                                              | 是否必填 |
| ------------------- | ------------------ | ----------------------------------------------------------------- | -------- |
| service             | string             | 服务名                                                            | 是       |
| namespace           | string             | 命名空间                                                          | 是       |
| host                | string             | 实例的IP                                                          | 是       |
| port                | string             | 实例的端口                                                        | 是       |
| vpc_id              | string             | VPC ID                                                            | 否       |
| protocol            | string             | 对应端口的协议                                                    | 否       |
| version             | string             | 版本                                                              | 否       |
| priority            | string             | 优先级                                                            | 否       |
| weight              | string             | 权重(默认值100)                                                   | 是       |
| enable_health_check | bool               | 是否开启健康检查                                                  | 是       |
| health_check        | HealthCheck        | 健康检查类别具体描述信息(如果enable_health_check==true，必须填写) | 否       |
| healthy             | bool               | 实例健康标志(默认为健康的)                                        | 是       |
| isolate             | bool               | 实例隔离标志(默认为不隔离的)                                      | 是       |
| location            | Location           | 实例位置信息                                                      | 是       |
| metadata            | map<string,string> | 实例标签信息，最多只能存储64对 *key-value*                         | 否       |
| service_token       | string             | service的token信息                                                | 是       |


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateInstancesIsolateRequest
*/
func (a *InstancesApiService) UpdateInstancesIsolate(ctx _context.Context) ApiUpdateInstancesIsolateRequest {
	return ApiUpdateInstancesIsolateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *InstancesApiService) UpdateInstancesIsolateExecute(r ApiUpdateInstancesIsolateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstancesApiService.UpdateInstancesIsolate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/instances/isolate/host"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
