/*
Polaris Server

一个支持多语言、多框架的云原生服务发现和治理中心  提供高性能SDK和无侵入Sidecar两种接入方式  

API version: v0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package polaris

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// RoutingRulesApiService RoutingRulesApi service
type RoutingRulesApiService service

type ApiCreateRoutingsRequest struct {
	ctx _context.Context
	ApiService *RoutingRulesApiService
	body *[]V1Routing
}

// create routing rules
func (r ApiCreateRoutingsRequest) Body(body []V1Routing) ApiCreateRoutingsRequest {
	r.body = &body
	return r
}

func (r ApiCreateRoutingsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateRoutingsExecute(r)
}

/*
CreateRoutings 创建路由规则


为服务创建一个路由规则，以对服务进行流量调度，一个服务只能有一个路由规则。

请求示例：

~~~
POST /naming/v1/routings

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

[
    {
        "service":"...",
        "namespace":"...",
        "inbounds":[
           {
              "sources": [
                 {
                   "service": "...",
                   "namespace": "...",
                   "metadata": {
                       "...": {
                         "type": "EXACT",
                         "value": "..."
                       }
                    }
                 }
              ],
              "destinations": [
                  {
                    "metadata": {
                       "...": {
                         "type": "EXACT",
                         "value": "..."
                       }
                    }
                    "weight": ...
                  }
              ]
           }
        ],
        "outbounds":[
            {
              "sources": [
                 {
                   "metadata": {
                       "...": {
                         "type": "EXACT",
                         "value": "..."
                       }
                    }
                 }
              ],
              "destinations": [
                  {
                   "service": "...",
                   "namespace": "...",                  
                    "metadata": {
                       "...": {
                         "type": "EXACT",
                         "value": "..."
                       }
                    }
                    "weight": ...
                  }
              ]
           }
        ],
        "service_token":"...",
    }
]
~~~

回复示例：

~~~
{
    "code":200000,
    "info":"...",
    "size":1,
    "responses":[
        {
            "code":200000,
            "info":"...",
            "routing":{
                "service":"...",
                "namespace":"..."
            }
        }
    ]
}
~~~

数据结构：

> routing结构参数

| 参数名    | 类型   | 描述               | 是否必填 |
| --------- | ------ | ------------------ | -------- |
| service   | string | 规则所属的服务名   | 是       |
| namespace | string | 规则所属的命名空间 | 是       |
| inbounds  | route[]    | 入流量规则 | 否 |
| outbounds | route[] | 出流量规则 | 否 |
| service_token | string | 鉴权token，当开启鉴权后需要传入 | 否 |

> route结构参数

| 参数名       | 类型    | 描述 | 是否必填 |
| ------------ | ------- | ---- | -------- |
| sources      | source[] | 请求匹配条件 | 否 |
| destinations | destination[] | 目标实例分组匹配条件 | 是 |

> source结构参数

| 参数名    | 类型                     | 描述                           | 是否必填 |
| --------- | ------------------------ | ------------------------------ | -------- |
| service   | string                   | 主调方服务名，填*代表全匹配    | 否       |
| namespace | string                   | 被调方服务名，填*代表全匹配    | 否       |
| metadata  | map<string, matchString> | 匹配参数，需全匹配所有KV才通过 | 否       |

> destination结构参数

| 参数名    | 类型                     | 描述                                                         | 是否必填 |
| --------- | ------------------------ | ------------------------------------------------------------ | -------- |
| service   | string                   | 被调方服务名，填*代表全匹配                                  | 否       |
| namespace | string                   | 被调方命名空间，填*代表全匹配                                | 否       |
| metadata  | map<string, matchString> | 示例标签匹配参数，需全匹配才通过                             | 否       |
| priority  | int32                    | 优先级，数值越小，优先级越高，请求会优先选取优先级最高的实例分组进行路由，只有该分组没有可用实例才会选择次高优先级的分组 | 否       |
| weight    | int32                    | 分组权重，优先级相同的多个分组，按权重比例进行请求分配       | 否       |

> matchString结构参数

| 参数名     | 类型   | 描述                                                         | 是否必填 |
| ---------- | ------ | ------------------------------------------------------------ | -------- |
| type       | string | 匹配类型，枚举值，支持：EXACT（全匹配，默认），REGEX（正则表达式匹配） | 否       |
| value      | string | 匹配的目标值                                                 | 是       |
| value_type | string | 值类型，枚举值，支持：TEXT（文本，默认），PARAMETER（参数，路由规则值使用动态参数时用到） | 否       |


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateRoutingsRequest
*/
func (a *RoutingRulesApiService) CreateRoutings(ctx _context.Context) ApiCreateRoutingsRequest {
	return ApiCreateRoutingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RoutingRulesApiService) CreateRoutingsExecute(r ApiCreateRoutingsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoutingRulesApiService.CreateRoutings")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/routings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteRoutingsRequest struct {
	ctx _context.Context
	ApiService *RoutingRulesApiService
	body *[]V1Routing
}

// delete routing rules
func (r ApiDeleteRoutingsRequest) Body(body []V1Routing) ApiDeleteRoutingsRequest {
	r.body = &body
	return r
}

func (r ApiDeleteRoutingsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteRoutingsExecute(r)
}

/*
DeleteRoutings 删除路由规则


删除服务下的路由规则

请求示例：

~~~
POST /naming/v1/routings/delete

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

[
    {
        "service_token":"...",
        "service":"...",
        "namespace":"..."
    }
]
~~~

回复示例：

~~~
{
    "code":200000,
    "info":"...",
    "size":1,
    "responses":[
        {
            "code":200000,
            "info":"...",
            "routing":{
                "service":"...",
                "namespace":"..."
            }
        }
    ]
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteRoutingsRequest
*/
func (a *RoutingRulesApiService) DeleteRoutings(ctx _context.Context) ApiDeleteRoutingsRequest {
	return ApiDeleteRoutingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RoutingRulesApiService) DeleteRoutingsExecute(r ApiDeleteRoutingsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoutingRulesApiService.DeleteRoutings")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/routings/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRoutingsRequest struct {
	ctx _context.Context
	ApiService *RoutingRulesApiService
	service string
	namespace string
	offset int32
	limit int32
}


func (r ApiGetRoutingsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetRoutingsExecute(r)
}

/*
GetRoutings 查询路由规则


请求示例：

~~~
GET /naming/v1/routings?参数名=参数值

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}
~~~

| 参数名    | 类型   | 描述                    | 是否必填 |
| --------- | ------ | ----------------------- | -------- |
| service   | string | 服务名                  | 否       |
| namespace | string | 命名空间                | 否       |
| offset    | int    | 分页的起始位置，默认为0 | 否       |
| limit     | int    | 每页行数，默认100       | 否       |

应答示例：

~~~
{
  	"code": ...,
  	"info": "...",
  	"amount": ...,
  	"size": ...,
  	"routings": [
    	{
          "service": "...",
          "namespace": "...",
          "inbounds": [...],
          "outbounds": [...],
          "ctime": "...",  // 创建时间
          "mtime": "..."   // 修改时间
    	}
  ]
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param service 服务名称
 @param namespace 命名空间
 @param offset 分页的起始位置，默认为0
 @param limit 每页行数，默认100
 @return ApiGetRoutingsRequest
*/
func (a *RoutingRulesApiService) GetRoutings(ctx _context.Context, service string, namespace string, offset int32, limit int32) ApiGetRoutingsRequest {
	return ApiGetRoutingsRequest{
		ApiService: a,
		ctx: ctx,
		service: service,
		namespace: namespace,
		offset: offset,
		limit: limit,
	}
}

// Execute executes the request
func (a *RoutingRulesApiService) GetRoutingsExecute(r ApiGetRoutingsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoutingRulesApiService.GetRoutings")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/routings"
	localVarPath = strings.Replace(localVarPath, "{"+"service"+"}", _neturl.PathEscape(parameterToString(r.service, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.PathEscape(parameterToString(r.namespace, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"offset"+"}", _neturl.PathEscape(parameterToString(r.offset, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"limit"+"}", _neturl.PathEscape(parameterToString(r.limit, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateRoutingsRequest struct {
	ctx _context.Context
	ApiService *RoutingRulesApiService
	body *[]V1Routing
}

// update routing rules
func (r ApiUpdateRoutingsRequest) Body(body []V1Routing) ApiUpdateRoutingsRequest {
	r.body = &body
	return r
}

func (r ApiUpdateRoutingsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateRoutingsExecute(r)
}

/*
UpdateRoutings 更新路由规则


更新服务下的路由规则的相关信息

请求示例：

~~~
PUT /naming/v1/routings

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

[
    {
        "service":"...",
        "namespace":"...",
        "inbounds":[...],
        "outbounds":[...],
        "service_token":"...",
    }
]
~~~

回复示例：

~~~
{
    "code":200000,
    "info":"...",
    "size":1,
    "responses":[
        {
            "code":200000,
            "info":"...",
            "routing":{
                "service":"...",
                "namespace":"..."
            }
        }
    ]
}
~~~

数据结构：

> routing结构参数

| 参数名    | 类型   | 描述               | 是否必填 |  |
| --------- | ------ | ------------------ | -------- | -------- |
| service   | string | 规则所属的服务名   | 是       | 否      |
| namespace | string | 规则所属的命名空间 | 是       | 否      |
| inbounds  | route[]    | 入流量规则 | 否 | 是 |
| outbounds | route[] | 出流量规则 | 否 | 是 |
| service_token | string | 鉴权token，当开启鉴权后需要传入 | 否 | 否 |


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateRoutingsRequest
*/
func (a *RoutingRulesApiService) UpdateRoutings(ctx _context.Context) ApiUpdateRoutingsRequest {
	return ApiUpdateRoutingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RoutingRulesApiService) UpdateRoutingsExecute(r ApiUpdateRoutingsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoutingRulesApiService.UpdateRoutings")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v1/routings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2CreateRoutingsRequest struct {
	ctx _context.Context
	ApiService *RoutingRulesApiService
	body *[]V2Routing
}

func (r ApiV2CreateRoutingsRequest) Body(body []V2Routing) ApiV2CreateRoutingsRequest {
	r.body = &body
	return r
}

func (r ApiV2CreateRoutingsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.V2CreateRoutingsExecute(r)
}

/*
V2CreateRoutings 创建路由规则


创建路由规则

~~~
POST /naming/v2/routings

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2CreateRoutingsRequest
*/
func (a *RoutingRulesApiService) V2CreateRoutings(ctx _context.Context) ApiV2CreateRoutingsRequest {
	return ApiV2CreateRoutingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RoutingRulesApiService) V2CreateRoutingsExecute(r ApiV2CreateRoutingsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoutingRulesApiService.V2CreateRoutings")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v2/routings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2DeleteRoutingsRequest struct {
	ctx _context.Context
	ApiService *RoutingRulesApiService
}


func (r ApiV2DeleteRoutingsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.V2DeleteRoutingsExecute(r)
}

/*
V2DeleteRoutings 删除路由规则


删除路由规则

~~~
DELETE /naming/v2/routings

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2DeleteRoutingsRequest
*/
func (a *RoutingRulesApiService) V2DeleteRoutings(ctx _context.Context) ApiV2DeleteRoutingsRequest {
	return ApiV2DeleteRoutingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RoutingRulesApiService) V2DeleteRoutingsExecute(r ApiV2DeleteRoutingsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoutingRulesApiService.V2DeleteRoutings")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v2/routings/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2EnableRoutingsRequest struct {
	ctx _context.Context
	ApiService *RoutingRulesApiService
}


func (r ApiV2EnableRoutingsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.V2EnableRoutingsExecute(r)
}

/*
V2EnableRoutings 启用路由规则


更新路由规则

~~~
PUT /naming/v2/routings

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2EnableRoutingsRequest
*/
func (a *RoutingRulesApiService) V2EnableRoutings(ctx _context.Context) ApiV2EnableRoutingsRequest {
	return ApiV2EnableRoutingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RoutingRulesApiService) V2EnableRoutingsExecute(r ApiV2EnableRoutingsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoutingRulesApiService.V2EnableRoutings")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v2/routings/enable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2GetRoutingsRequest struct {
	ctx _context.Context
	ApiService *RoutingRulesApiService
}


func (r ApiV2GetRoutingsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.V2GetRoutingsExecute(r)
}

/*
V2GetRoutings 获取路由规则


获取路由规则

~~~
GET /naming/v2/routings

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2GetRoutingsRequest
*/
func (a *RoutingRulesApiService) V2GetRoutings(ctx _context.Context) ApiV2GetRoutingsRequest {
	return ApiV2GetRoutingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RoutingRulesApiService) V2GetRoutingsExecute(r ApiV2GetRoutingsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoutingRulesApiService.V2GetRoutings")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v2/routings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV2UpdateRoutingsRequest struct {
	ctx _context.Context
	ApiService *RoutingRulesApiService
	body *[]V2Routing
}

func (r ApiV2UpdateRoutingsRequest) Body(body []V2Routing) ApiV2UpdateRoutingsRequest {
	r.body = &body
	return r
}

func (r ApiV2UpdateRoutingsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.V2UpdateRoutingsExecute(r)
}

/*
V2UpdateRoutings 更新路由规则


更新路由规则

~~~
PUT /naming/v2/routings

# 开启北极星服务端针对控制台接口鉴权开关后，需要添加下面的 header
Header X-Polaris-Token: {访问凭据}

~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2UpdateRoutingsRequest
*/
func (a *RoutingRulesApiService) V2UpdateRoutings(ctx _context.Context) ApiV2UpdateRoutingsRequest {
	return ApiV2UpdateRoutingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *RoutingRulesApiService) V2UpdateRoutingsExecute(r ApiV2UpdateRoutingsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoutingRulesApiService.V2UpdateRoutings")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/naming/v2/routings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
