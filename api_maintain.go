/*
Polaris Server

一个支持多语言、多框架的云原生服务发现和治理中心  提供高性能SDK和无侵入Sidecar两种接入方式  

API version: v0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package polaris

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// MaintainApiService MaintainApi service
type MaintainApiService service

type ApiCleanInstanceRequest struct {
	ctx _context.Context
	ApiService *MaintainApiService
	body *V1Instance
}

func (r ApiCleanInstanceRequest) Body(body V1Instance) ApiCleanInstanceRequest {
	r.body = &body
	return r
}

func (r ApiCleanInstanceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CleanInstanceExecute(r)
}

/*
CleanInstance 彻底清理flag=1的实例


请求示例：

~~~
POST /maintain/v1/instance/clean
Header X-Polaris-Token: {访问凭据}
Header Content-Type: application/json

{
    "service": "tdsql-ops-server",
    "namespace": "default",
    "host": "127.0.0.1",
    "port": 8080,
    "location": {
        "region": "ap-guangzhou",
        "zone": "ap-guangzhou-3",
        "campus": ""
    },
    "enable_health_check": true,
    "health_check": {
        "type": 1,
        "heartbeat": {
            "ttl": 10
        }
    },
    "metadata": {
        "env": "pre"
    }
}
~~~



 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCleanInstanceRequest
*/
func (a *MaintainApiService) CleanInstance(ctx _context.Context) ApiCleanInstanceRequest {
	return ApiCleanInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MaintainApiService) CleanInstanceExecute(r ApiCleanInstanceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainApiService.CleanInstance")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/maintain/v1/instance/clean"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCloseConnectionsRequest struct {
	ctx _context.Context
	ApiService *MaintainApiService
	body *[]MaintainConnReq
}

func (r ApiCloseConnectionsRequest) Body(body []MaintainConnReq) ApiCloseConnectionsRequest {
	r.body = &body
	return r
}

func (r ApiCloseConnectionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CloseConnectionsExecute(r)
}

/*
CloseConnections 关闭指定client ip的连接


请求示例：

~~~
POST /maintain/v1/apiserver/conn?protocol=xxx&host=xxx
Header X-Polaris-Token: {访问凭据}
Header Content-Type: application/json

[
    {
        "protocol": "someProtocol",
        "host": "someHost",
        "amount": "someAmount",
        "port": "port",
    } 
]
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCloseConnectionsRequest
*/
func (a *MaintainApiService) CloseConnections(ctx _context.Context) ApiCloseConnectionsRequest {
	return ApiCloseConnectionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MaintainApiService) CloseConnectionsExecute(r ApiCloseConnectionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainApiService.CloseConnections")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/maintain/v1/apiserver/conn/close"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFreeOSMemoryRequest struct {
	ctx _context.Context
	ApiService *MaintainApiService
}


func (r ApiFreeOSMemoryRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.FreeOSMemoryExecute(r)
}

/*
FreeOSMemory 释放系统内存


请求示例：

~~~
POST /maintain/v1/memory/free
Header X-Polaris-Token: {访问凭据}
Header Content-Type: application/json
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFreeOSMemoryRequest
*/
func (a *MaintainApiService) FreeOSMemory(ctx _context.Context) ApiFreeOSMemoryRequest {
	return ApiFreeOSMemoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MaintainApiService) FreeOSMemoryExecute(r ApiFreeOSMemoryRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainApiService.FreeOSMemory")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/maintain/v1/memory/free"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetLastHeartbeatRequest struct {
	ctx _context.Context
	ApiService *MaintainApiService
	id *string
	service *string
	namespace *string
	host *string
	port *int32
	vpvId *string
}

// 实例ID 如果存在则其它参数可不填
func (r ApiGetLastHeartbeatRequest) Id(id string) ApiGetLastHeartbeatRequest {
	r.id = &id
	return r
}
// 服务名
func (r ApiGetLastHeartbeatRequest) Service(service string) ApiGetLastHeartbeatRequest {
	r.service = &service
	return r
}
// 命名空间
func (r ApiGetLastHeartbeatRequest) Namespace(namespace string) ApiGetLastHeartbeatRequest {
	r.namespace = &namespace
	return r
}
// 主机名
func (r ApiGetLastHeartbeatRequest) Host(host string) ApiGetLastHeartbeatRequest {
	r.host = &host
	return r
}
// 端口
func (r ApiGetLastHeartbeatRequest) Port(port int32) ApiGetLastHeartbeatRequest {
	r.port = &port
	return r
}
// VPC ID
func (r ApiGetLastHeartbeatRequest) VpvId(vpvId string) ApiGetLastHeartbeatRequest {
	r.vpvId = &vpvId
	return r
}

func (r ApiGetLastHeartbeatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetLastHeartbeatExecute(r)
}

/*
GetLastHeartbeat 获取上一次心跳的时间


请求示例：

~~~
GET /maintain/v1//instance/heartbeat?id=xxx
Header X-Polaris-Token: {访问凭据}
~~~

请求参数：

| 参数名              | 类型               | 描述                                                              | 是否必填 |
| ------------------- | ------------------ | ----------------------------------------------------------------- | -------- |
| id                  | string             | 实例id 如果存在id，后面参数可以不填名                                   | 否       |
| service             | string             | 服务名                                                            | 否       |
| namespace           | string             | 命名空间                                                          | 否       |
| host                | string             | 实例的IP                                                          | 否       |
| port                | string             | 实例的端口                                                        | 否       |
| vpc_id              | string             | VPC ID                                                            | 否       |


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLastHeartbeatRequest
*/
func (a *MaintainApiService) GetLastHeartbeat(ctx _context.Context) ApiGetLastHeartbeatRequest {
	return ApiGetLastHeartbeatRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MaintainApiService) GetLastHeartbeatExecute(r ApiGetLastHeartbeatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainApiService.GetLastHeartbeat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/maintain/v1/instance/heartbeat"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.service != nil {
		localVarQueryParams.Add("service", parameterToString(*r.service, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.port != nil {
		localVarQueryParams.Add("port", parameterToString(*r.port, ""))
	}
	if r.vpvId != nil {
		localVarQueryParams.Add("vpv_id", parameterToString(*r.vpvId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetLogOutputLevelRequest struct {
	ctx _context.Context
	ApiService *MaintainApiService
}


func (r ApiGetLogOutputLevelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetLogOutputLevelExecute(r)
}

/*
GetLogOutputLevel 获取日志输出级别


请求示例：

~~~
GET /maintain/v1/log/outputlevel
Header X-Polaris-Token: {访问凭据}
~~~

返回示例：
~~~
{
 "apiserver": "info",
 "auth": "info",
 "cache": "info",
 "config": "info",
 "default": "info",
 "healthcheck": "info",
 "naming": "info",
 "store": "info",
 "xdsv3": "info"
}
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLogOutputLevelRequest
*/
func (a *MaintainApiService) GetLogOutputLevel(ctx _context.Context) ApiGetLogOutputLevelRequest {
	return ApiGetLogOutputLevelRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MaintainApiService) GetLogOutputLevelExecute(r ApiGetLogOutputLevelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainApiService.GetLogOutputLevel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/maintain/v1/log/outputlevel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetServerConnStatsRequest struct {
	ctx _context.Context
	ApiService *MaintainApiService
	protocol *string
	host *string
	amount *int32
}

// 查看指定协议
func (r ApiGetServerConnStatsRequest) Protocol(protocol string) ApiGetServerConnStatsRequest {
	r.protocol = &protocol
	return r
}
// 查看指定host
func (r ApiGetServerConnStatsRequest) Host(host string) ApiGetServerConnStatsRequest {
	r.host = &host
	return r
}
// 总数
func (r ApiGetServerConnStatsRequest) Amount(amount int32) ApiGetServerConnStatsRequest {
	r.amount = &amount
	return r
}

func (r ApiGetServerConnStatsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetServerConnStatsExecute(r)
}

/*
GetServerConnStats 获取服务端连接统计信息


请求示例：
~~~
GET /maintain/v1/apiserver/conn/stats?protocol=xxx&host=xxx
Header X-Polaris-Token: {访问凭据}
~~~

| 参数名   	| 类型   	| 描述                	| 是否必填 	|
|----------	|--------	|---------------------	|----------	|
| protocol 	| string 	| 查看指定协议 server 	| 是       	|
| host     	| string 	| 查看指定host        	| 否       	|
| amount   	| integer 	| 总量                	| 否       	|


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetServerConnStatsRequest
*/
func (a *MaintainApiService) GetServerConnStats(ctx _context.Context) ApiGetServerConnStatsRequest {
	return ApiGetServerConnStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MaintainApiService) GetServerConnStatsExecute(r ApiGetServerConnStatsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainApiService.GetServerConnStats")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/maintain/v1/apiserver/conn/stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.protocol == nil {
		return nil, reportError("protocol is required and must be specified")
	}

	localVarQueryParams.Add("protocol", parameterToString(*r.protocol, ""))
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.amount != nil {
		localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetServerConnectionsRequest struct {
	ctx _context.Context
	ApiService *MaintainApiService
	protocol *string
	host *string
}

// 查看指定协议
func (r ApiGetServerConnectionsRequest) Protocol(protocol string) ApiGetServerConnectionsRequest {
	r.protocol = &protocol
	return r
}
// 查看指定host
func (r ApiGetServerConnectionsRequest) Host(host string) ApiGetServerConnectionsRequest {
	r.host = &host
	return r
}

func (r ApiGetServerConnectionsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetServerConnectionsExecute(r)
}

/*
GetServerConnections 获取服务端连接数


请求示例：

~~~
GET /maintain/v1/apiserver/conn?protocol=xxx&host=xxx
Header X-Polaris-Token: {访问凭据}
~~~

| 参数名   | 类型   | 描述                | 是否必填 |
|----------|--------|---------------------|----------|
| protocol | string | 查看指定协议 server | 是       |
| host     | string | 查看指定host        | 否       |

应答示例：

~~~json
~~~


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetServerConnectionsRequest
*/
func (a *MaintainApiService) GetServerConnections(ctx _context.Context) ApiGetServerConnectionsRequest {
	return ApiGetServerConnectionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MaintainApiService) GetServerConnectionsExecute(r ApiGetServerConnectionsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainApiService.GetServerConnections")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/maintain/v1/apiserver/conn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.protocol == nil {
		return nil, reportError("protocol is required and must be specified")
	}

	localVarQueryParams.Add("protocol", parameterToString(*r.protocol, ""))
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetLogOutputLevelRequest struct {
	ctx _context.Context
	ApiService *MaintainApiService
}


func (r ApiSetLogOutputLevelRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SetLogOutputLevelExecute(r)
}

/*
SetLogOutputLevel 设置日志输出级别


请求示例：

~~~
POST /maintain/v1/log/outputlevel
Header X-Polaris-Token: {访问凭据}

{
    "scope": "apiserver",
    "level": "info"
}


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetLogOutputLevelRequest
*/
func (a *MaintainApiService) SetLogOutputLevel(ctx _context.Context) ApiSetLogOutputLevelRequest {
	return ApiSetLogOutputLevelRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MaintainApiService) SetLogOutputLevelExecute(r ApiSetLogOutputLevelRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MaintainApiService.SetLogOutputLevel")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/maintain/v1/log/outputlevel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Polaris-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
